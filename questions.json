[
  {
    "id": 1,
    "title": "Sum 2 CLI arguments [EASY]",
    "code": "const args = process.argv.slice(2);\n// console.log(args)\n\nconst num1 = Number(args[0]);\nconst num2 = Number(args[1]);\n\nconst sum = num1 + num2;\n\nconsole.log(sum);"
  },
  {
    "id": 2,
    "title": "Sum 2 numbers from files and save result [EASY]",
    "code": "const fs = require('fs');\n\nconst data1 = fs.readFileSync('./file1.txt', 'utf8');\nconst data2 = fs.readFileSync('./file2.txt', 'utf8');\n\nconst num1 = Number(data1);\nconst num2 = Number(data2);\n\nconst sum = num1 + num2;\n\nconst result = sum.toString();\n\nfs.writeFileSync('./result.txt', result);"
  },
  {
    "id": 3,
    "title": "Async Todo Creation with File Append [MEDIUM]",
    "code": "const fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst DB_FILE_PATH = path.join(__dirname, \"db.txt\");\n\n/**\n * Converts an array of todo objects into a newline-separated string,\n * where each todo object is formatted as pretty-printed JSON.\n * This format is compatible with the expected structure of the db.txt file.\n *\n * @param {Array<Object>} Json - Array of todo objects to be converted.\n * @returns {string} Newline-separated JSON strings representing todos.\n */\nfunction JsonToDbText(Json){\n  let text = \"\";\n  Json.forEach((todo) => {\n    text += JSON.stringify(todo, null, 2) + \"\\n\";\n  });\n  return text;\n};\n\nconst createTodo = (todo) => {\n  return new Promise((res, rej) => {\n    const toDoObj = {\n      id: Date.now(),\n      title: todo,\n      isCompleted: false,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    }\n\n    fs.appendFile(DB_FILE_PATH, JsonToDbText([toDoObj]), (err) => {\n      if (err) {\n        return rej(err);\n      }\n      else {\n        return res(todo)\n      }\n    })\n  })\n};"
  },
  {
    "id": 4,
    "title": "Simple HTTP Server with File Read [EASY]",
    "code": "const http = require('http');\nconst fs = require('fs');\n\nconst server = http.createServer((req, res) => {\n  // Your code here\n  if (req.method === 'GET' && req.url === '/read') {\n    // Read file asynchronously\n    fs.readFile('message.txt', 'utf8', (err, data) => {\n      if (err) {\n        // Handle file read errors (e.g., file doesn't exist)\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('Internal Server Error');\n        return;\n      }\n      \n      // Send file content as response\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end(data);\n    });\n  } else {\n    // Handle all other routes\n    res.writeHead(404, { 'Content-Type': 'text/plain' });\n    res.end('Not Found');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server is listening on port 3000');\n});\n\nmodule.exports = server;"
  },
  {
    "id": 5,
    "title": "Express API with validation endpoint [MEDIUM]",
    "code": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Create the API here\napp.get('/validatepost', (req, res) => {\n  // Get title and content from query parameters\n  const { title, content } = req.query;\n  \n  // Check if both title and content exist and are not empty strings\n  if (!title || title.trim() === '' || !content || content.trim() === '') {\n    return res.status(400).json({ \n      \"error\": \"Both title and content are required and cannot be empty.\" \n    });\n  }\n  \n  // If validation is successful\n  res.status(200).json({\n    \"message\": \"Validation successful\",\n    \"post\": {\n      \"title\": title,\n      \"content\": content\n    }\n  });\n});\n\napp.listen(port, () => {\n  console.log(`App listening at http://localhost:${port}`);\n});\n\nmodule.exports = { app };"
  },
  {
    "id": 6,
    "title": "Middleware for Query-Based User Validation in Express.js [HARD]",
    "codes": {
      "index.js": "const express = require(\"express\");\nconst dotenv = require(\"dotenv\");\nconst { validateUser } = require(\"./validateMiddleware\");\n\nconst app = express();\ndotenv.config();\n\n// Add middleware here\napp.get(\"/user\", validateUser, (req, res) => {\n    // YOUR CODE\n    const { name, age, city } = req.query;\n    res.status(200).json({\n        message: `Welcome, ${name.trim()} from ${city.trim()}! your age is ${age}`\n    });\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n    console.log(`Server running on http://localhost:${PORT}`);\n});",
      
      "validateMiddleware.js": "function validateUser(req, res, next) {\n    const { name, age, city } = req.query;\n    \n    // Validate name\n    if (!name || typeof name !== 'string') {\n        return res.status(400).json({ error: \"Invalid name\" });\n    }\n    \n    const trimmedName = name.trim();\n    if (trimmedName.length < 4) {\n        return res.status(400).json({ error: \"Invalid name\" });\n    }\n    \n    if (!/^[A-Za-z]+$/.test(trimmedName)) {\n        return res.status(400).json({ error: \"Invalid name\" });\n    }\n    \n    // Validate age\n    if (!age) {\n        return res.status(400).json({ error: \"Invalid age\" });\n    }\n    \n    if (typeof age !== 'string' || !/^\\d+$/.test(age)) {\n        return res.status(400).json({ error: \"Invalid age\" });\n    }\n    \n    const ageNum = parseInt(age, 10);\n    if (isNaN(ageNum) || ageNum < 18 || ageNum > 100) {\n        return res.status(400).json({ error: \"Invalid age\" });\n    }\n    \n    // Check for leading zeros\n    if (age.length > 1 && age.startsWith('0')) {\n        return res.status(400).json({ error: \"Invalid age\" });\n    }\n    \n    // Validate city\n    if (!city || typeof city !== 'string') {\n        return res.status(400).json({ error: \"Invalid city\" });\n    }\n    \n    const trimmedCity = city.trim();\n    if (trimmedCity.length < 4) {\n        return res.status(400).json({ error: \"Invalid city\" });\n    }\n    \n    const validCities = [\"Mumbai\", \"Delhi\", \"Bangalore\", \"Kolkata\"];\n    if (!validCities.includes(trimmedCity)) {\n        return res.status(400).json({ error: \"Invalid city\" });\n    }\n    \n    // All validations passed\n    next();\n}\n\nmodule.exports = { validateUser };"
    }
  },
  {
    "id": 7,
    "title": "Express REST Update-Delete [HARD]",
    "code": "const express = require(\"express\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst app = express();\napp.use(express.json());\n\nconst DB_FILE_PATH = path.join(__dirname, \"db.json\");\n\n// Utility to read users\nconst readUsersFromFile = () => {\n  const data = fs.readFileSync(DB_FILE_PATH, \"utf-8\");\n  return JSON.parse(data);\n};\n\n// Utility to write users\nconst writeUsersToFile = (users) => {\n  fs.writeFileSync(DB_FILE_PATH, JSON.stringify(users, null, 2), \"utf-8\");\n};\n\n// ✅ Task 1: Update user name\napp.patch(\"/users/:id\", (req, res) => {\n  const userId = req.params.id;\n  const { name } = req.body;\n\n  if (!name || typeof name !== \"string\" || name.trim() === \"\") {\n    return res.status(400).json({ error: \"Invalid name\" });\n  }\n\n  const users = readUsersFromFile();\n  const userIndex = users.findIndex((u) => u.id === userId);\n\n  if (userIndex === -1) {\n    return res.status(404).json({ error: \"User does not exist\" });\n  }\n\n  users[userIndex].name = name;\n  writeUsersToFile(users);\n\n  return res.status(200).json(users[userIndex]);\n});\n\n// ✅ Task 2: Delete user\napp.delete(\"/users/:id\", (req, res) => {\n  const userId = req.params.id;\n\n  const users = readUsersFromFile();\n  const userIndex = users.findIndex((u) => u.id === userId);\n\n  if (userIndex === -1) {\n    return res.status(404).json({ error: \"User does not exist\" });\n  }\n\n  const deletedUser = users.splice(userIndex, 1)[0];\n  writeUsersToFile(users);\n\n  return res.status(200).json(deletedUser);\n});\n\n// Start the server\napp.listen(3000, () => {\n  console.log(\"Server running on http://localhost:3000\");\n});\n\nmodule.exports = app;"
  },
  {
    "id": 8,
    "title": "Express REST Pagination [MEDIUM]",
    "codes": {
      "index.js": "const express = require(\"express\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst app = express();\napp.use(express.json());\n\nconst DB_FILE_PATH = path.join(__dirname, \"db.json\");\n\nconst readUsersFromFile = () => {\n  const data = fs.readFileSync(DB_FILE_PATH, \"utf-8\");\n  return JSON.parse(data);\n};\n\n// GET /users with pagination\napp.get('/users', (req, res) => {\n  const users = readUsersFromFile();\n\n  let { limit, offset } = req.query;\n\n  limit = Number(limit);\n  offset = Number(offset);\n\n  if (isNaN(offset) || offset < 0) offset = 0;\n\n  // If limit is invalid or larger than number of users, return all\n  if (isNaN(limit) || limit >= users.length) {\n    return res.status(200).json(users);\n  }\n\n  const startIndex = offset * limit;\n  const endIndex = startIndex + limit;\n\n  // If offset * limit is out of bounds, return empty array\n  if (startIndex >= users.length) {\n    return res.status(200).json([]);\n  }\n\n  const paginatedUsers = users.slice(startIndex, endIndex);\n  return res.status(200).json(paginatedUsers);\n});\n\napp.listen(3000, () => {\n  console.log(`Server running on http://localhost:3000`);\n});\n\nmodule.exports = app;",
      "readUsersFromFile.js": "const fs = require(\"fs\");\nconst path = require(\"path\");\n\nfunction readUsersFromFile() {\n  const filePath = path.join(__dirname, \"db.json\");\n  const data = fs.readFileSync(filePath, \"utf-8\");\n  return JSON.parse(data);\n}\n\nmodule.exports = { readUsersFromFile };"
    }
  },
  {
    "id": 9,
    "title": "Express REST Sorting [MEDIUM]",
    "code": "const express = require(\"express\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst app = express();\napp.use(express.json());\n\nconst DB_FILE_PATH = path.join(__dirname, \"db.json\");\n\nconst readUsersFromFile = () => {\n  const data = fs.readFileSync(DB_FILE_PATH, \"utf-8\");\n  return JSON.parse(data);\n}\n\n// Write your code here..\napp.get(\"/users\", (req, res) => {\n  const { sortBy, order = 'asc' } = req.query;\n  \n  // Validate sortBy parameter\n  if (sortBy !== 'id' && sortBy !== 'name') {\n    return res.status(400).json({ error: \"Invalid sortBy parameter\" });\n  }\n  \n  // Validate order parameter\n  if (order !== 'asc' && order !== 'desc') {\n    return res.status(400).json({ error: \"Invalid order parameter\" });\n  }\n  \n  const users = readUsersFromFile();\n  \n  // Sort users based on criteria\n  let sortedUsers;\n  \n  if (sortBy === 'id') {\n    sortedUsers = users.sort((a, b) => {\n      const idA = parseInt(a.id);\n      const idB = parseInt(b.id);\n      return order === 'asc' ? idA - idB : idB - idA;\n    });\n  } else if (sortBy === 'name') {\n    sortedUsers = users.sort((a, b) => {\n      if (order === 'asc') {\n        return a.name.localeCompare(b.name);\n      } else {\n        return b.name.localeCompare(a.name);\n      }\n    });\n  }\n  \n  res.status(200).json(sortedUsers);\n});\n\napp.listen(3000, () => {\n  console.log(`server running on http://localhost:3000`);\n})\n\nmodule.exports = app;"
  },
  {
    "id": 10,
    "title": "Product: Update by ID [MEDIUM]",
    "code": "const express = require(\"express\");\nconst EventEmitter = require(\"events\");\n\nconst { pool } = require(\"../db/config.js\");\nconst { createProducts, createCart } = require(\"./migration\");\n\nrequire(\"dotenv\").config();\nconst serverStatus = new EventEmitter();\nconst port = process.env.PORT;\nconst app = express();\napp.use(express.json());\n\napp.post(\"/products\", async (req, res) => {\n  const { name, quantity, price } = req.body;\n  if (!name || !quantity || !price) {\n    return res.status(400).json({ error: \"invalid input\" });\n  }\n  try {\n    const [result] = await pool.query(\n      \"INSERT INTO products (name, quantity, price) VALUES (?, ?, ?)\",\n      [name, quantity, price]\n    );\n    return res.status(201).json({ id: result.insertId, name, quantity, price });\n  } catch (err) {\n    if (err.code === \"ER_DUP_ENTRY\") {\n      return res.status(400).json({ error: \"Product name must be unique\" });\n    }\n    console.error(err);\n    return res.status(500).json({ error: \"Failed to create product\" });\n  }\n});\n\napp.put(\"/products/:id\", async (req, res) => {\n  const productId = req.params.id;\n  const { name, quantity, price } = req.body;\n\n  if (isNaN(productId)) {\n    return res.status(400).json({ error: \"Product ID must be a numeric value\" });\n  }\n\n  try {\n    const [existingProducts] = await pool.query(\n      \"SELECT * FROM products WHERE id = ?\",\n      [productId]\n    );\n\n    if (existingProducts.length === 0) {\n      return res.status(404).json({ error: \"Product not found\" });\n    }\n\n    const currentProduct = existingProducts[0];\n\n    if (name && name !== currentProduct.name) {\n      const [existingNames] = await pool.query(\n        \"SELECT id FROM products WHERE name = ? AND id != ?\",\n        [name, productId]\n      );\n      if (existingNames.length > 0) {\n        return res.status(400).json({ error: \"Product name must be unique\" });\n      }\n    }\n\n    const updateFields = [];\n    const updateValues = [];\n\n    if (name !== undefined) {\n      updateFields.push(\"name = ?\");\n      updateValues.push(name);\n    }\n\n    if (quantity !== undefined) {\n      updateFields.push(\"quantity = ?\");\n      updateValues.push(quantity);\n    }\n\n    if (price !== undefined) {\n      updateFields.push(\"price = ?\");\n      updateValues.push(price);\n    }\n\n    if (updateFields.length === 0) {\n      return res.status(400).json({ error: \"No fields provided for update\" });\n    }\n\n    updateValues.push(productId);\n    const updateQuery = `UPDATE products SET ${updateFields.join(\", \")} WHERE id = ?`;\n    await pool.query(updateQuery, updateValues);\n\n    const [updatedProducts] = await pool.query(\n      \"SELECT * FROM products WHERE id = ?\",\n      [productId]\n    );\n\n    const updatedProduct = updatedProducts[0];\n\n    return res.status(200).json({\n      message: \"Product is updated successfully\",\n      updatedData: {\n        id: updatedProduct.id,\n        name: updatedProduct.name,\n        quantity: updatedProduct.quantity,\n        price: updatedProduct.price\n      }\n    });\n  } catch (err) {\n    console.error(\"Error updating product:\", err);\n    if (err.code === \"ER_DUP_ENTRY\") {\n      return res.status(400).json({ error: \"Product name must be unique\" });\n    }\n    return res.status(500).json({ error: \"Failed to update product\" });\n  }\n});\n\npool\n  .getConnection()\n  .then(() => {\n    console.log(\"db connected\");\n  })\n  .then(createProducts)\n  .then(() => {\n    console.log(\"products table created\");\n  })\n  .then(createCart)\n  .then(() => {\n    console.log(\"cart table created\");\n  })\n  .then(() => {\n    app.listen(port, () => {\n      console.log(`Server running at http://localhost:${port}`);\n      serverStatus.emit(\"accepting api calls\");\n    });\n  }).catch((err) => console.log(err));\n\nmodule.exports = { app, serverStatus };"
  },
  {
    "id": 11,
    "title": "Delete Product [MEDIUM]",
    "code": "const express = require(\"express\");\nconst EventEmitter = require(\"events\");\n\nconst { pool } = require(\"../db/config.js\");\nconst { createProducts, createCart } = require(\"./migration\");\n\nrequire(\"dotenv\").config();\nconst serverStatus = new EventEmitter();\nconst port = process.env.PORT;\nconst app = express();\napp.use(express.json());\n\napp.post(\"/products\", async (req, res) => {\n  const { name, quantity, price } = req.body;\n  if (!name || !quantity || !price) {\n    return res.status(400).json({ error: \"invalid input\" });\n  }\n  try {\n    const [result] = await pool.query(\n      \"INSERT INTO products (name, quantity, price) VALUES (?, ?, ?)\",\n      [name, quantity, price]\n    );\n    return res.status(201).json({ id: result.insertId, name, quantity, price });\n  } catch (err) {\n    if (err.code === \"ER_DUP_ENTRY\") {\n      return res.status(400).json({ error: \"Product name must be unique\" });\n    }\n    console.error(err);\n    return res.status(500).json({ error: \"Failed to create product\" });\n  }\n});\n\n// Delete product by ID\napp.delete(\"/products/:id\", async (req, res) => {\n  const productId = req.params.id;\n\n  if (isNaN(productId)) {\n    return res.status(400).json({ error: \"Product ID must be a valid number\" });\n  }\n\n  try {\n    const [products] = await pool.query(\n      \"SELECT id FROM products WHERE id = ?\",\n      [productId]\n    );\n\n    if (products.length === 0) {\n      return res.status(404).json({ error: \"Product not found\" });\n    }\n\n    const connection = await pool.getConnection();\n    await connection.beginTransaction();\n\n    try {\n      await connection.query(\n        \"DELETE FROM cart WHERE product_id = ?\",\n        [productId]\n      );\n\n      const [result] = await connection.query(\n        \"DELETE FROM products WHERE id = ?\",\n        [productId]\n      );\n\n      await connection.commit();\n      connection.release();\n\n      return res.status(204).send();\n\n    } catch (transactionError) {\n      await connection.rollback();\n      connection.release();\n      throw transactionError;\n    }\n\n  } catch (err) {\n    console.error(\"Error deleting product:\", err);\n    return res.status(500).json({ error: \"Failed to delete product\" });\n  }\n});\n\npool\n  .getConnection()\n  .then(() => {\n    console.log(\"db connected\");\n  })\n  .then(createProducts)\n  .then(() => {\n    console.log(\"products table created\");\n  })\n  .then(createCart)\n  .then(() => {\n    console.log(\"cart table created\");\n  })\n  .then(() => {\n    app.listen(port, () => {\n      console.log(`Server running at http://localhost:${port}`);\n      serverStatus.emit(\"accepting api calls\");\n    });\n  }).catch((err) => console.log(err));\n\nmodule.exports = { app, serverStatus };"
  },
  {
    "id": 12,
    "title": "Prisma User Model for WebSeries [MEDIUM]",
    "code": {
      "index.js": "const express = require('express');\nconst dotenv = require('dotenv');\nconst { PrismaClient } = require('@prisma/client');\n\n// Load environment variables\ndotenv.config();\n\n// Creating Prisma instance\nconst prisma = new PrismaClient({\n  log: ['query', 'info', 'warn', 'error'],\n});\n\n// Creating App\nconst app = express();\n\n// Middleware to parse JSON requests\napp.use(express.json());\n\n// Define routes\napp.get('/', (req, res) => {\n    res.status(200).send(\"Hello World!!\");\n});\n\n// Example route to demonstrate Prisma usage\napp.post('/users', async (req, res) => {\n  try {\n    const { name, email, password, role, preferences } = req.body;\n    \n    const user = await prisma.user.create({\n      data: {\n        name,\n        email,\n        password,\n        role: role || \"guest\",\n        preferences\n      }\n    });\n    \n    res.status(201).json(user);\n  } catch (error) {\n    console.error('Error creating user:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\napp.get('/users', async (req, res) => {\n  try {\n    const users = await prisma.user.findMany();\n    res.json(users);\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// Set the port from environment variable or default to 3000\nconst port = process.env.PORT || 3000;\n\n// Start the server\napp.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n});\n\n// Graceful shutdown\nprocess.on('SIGINT', async () => {\n  await prisma.$disconnect();\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', async () => {\n  await prisma.$disconnect();\n  process.exit(0);\n});\n\n// Export app and prisma instances\nmodule.exports = { app, prisma };",
      "schema.prisma": "datasource db {\n  url      = env(\"DATABASE_URL\")\n  provider = \"mysql\"\n}\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\nmodel User {\n  id          Int      @id @default(autoincrement())\n  name        String\n  email       String   @unique\n  password    String\n  role        String   @default(\"guest\")\n  preferences Json?\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n\n  @@map(\"users\")\n}"
    }
  },
  {
    "id": 13,
    "title": "Build a WebSeries Table Using Prisma [MEDIUM]",
    "codes": {
      "index.js": "const express = require('express');\nconst { PrismaClient } = require('@prisma/client');\nconst dotenv = require('dotenv');\n\n// Load environment variables\ndotenv.config();\n\n// Creating App\nconst app = express();\n\n// Creating Prisma instance\nconst prisma = new PrismaClient({\n  log: ['query', 'info', 'warn', 'error'],\n});\n\n// Middleware to parse JSON requests\napp.use(express.json());\n\n// Define routes\napp.get('/', (req, res) => {\n    res.status(200).send(\"Hello World!!\");\n});\n\n// WebSeries routes\napp.post('/web-series', async (req, res) => {\n  try {\n    const { title, genre, releaseYear, isActive } = req.body;\n    \n    if (!title) {\n      return res.status(400).json({ error: 'Title is required' });\n    }\n\n    const webSeries = await prisma.webSeries.create({\n      data: {\n        title,\n        genre,\n        releaseYear,\n        isActive: isActive !== undefined ? isActive : true\n      }\n    });\n    \n    res.status(201).json(webSeries);\n  } catch (error) {\n    console.error('Error creating web series:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\napp.get('/web-series', async (req, res) => {\n  try {\n    const webSeries = await prisma.webSeries.findMany({\n      orderBy: {\n        id: 'asc'\n      }\n    });\n    res.json(webSeries);\n  } catch (error) {\n    console.error('Error fetching web series:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\napp.get('/web-series/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const webSeries = await prisma.webSeries.findUnique({\n      where: { id: parseInt(id) }\n    });\n\n    if (!webSeries) {\n      return res.status(404).json({ error: 'Web series not found' });\n    }\n\n    res.json(webSeries);\n  } catch (error) {\n    console.error('Error fetching web series:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\napp.put('/web-series/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { title, genre, releaseYear, isActive } = req.body;\n\n    const webSeries = await prisma.webSeries.update({\n      where: { id: parseInt(id) },\n      data: {\n        title,\n        genre,\n        releaseYear,\n        isActive\n      }\n    });\n\n    res.json(webSeries);\n  } catch (error) {\n    if (error.code === 'P2025') {\n      return res.status(404).json({ error: 'Web series not found' });\n    }\n    console.error('Error updating web series:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\napp.delete('/web-series/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    await prisma.webSeries.delete({\n      where: { id: parseInt(id) }\n    });\n\n    res.status(204).send();\n  } catch (error) {\n    if (error.code === 'P2025') {\n      return res.status(404).json({ error: 'Web series not found' });\n    }\n    console.error('Error deleting web series:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// Test endpoint for Prisma client\napp.get('/test/prisma', async (req, res) => {\n  try {\n    // Test Prisma connection\n    await prisma.$queryRaw`SELECT 1`;\n    \n    // Test WebSeries table access\n    const count = await prisma.webSeries.count();\n    \n    res.json({\n      status: 'OK',\n      message: 'Prisma client is working correctly',\n      tableAccess: 'WebSeries table is accessible',\n      totalRecords: count\n    });\n  } catch (error) {\n    res.status(500).json({\n      status: 'ERROR',\n      message: 'Prisma client test failed',\n      error: error.message\n    });\n  }\n});\n\n// Test endpoint for field validation\napp.get('/test/fields', async (req, res) => {\n  try {\n    // Create a test record to validate field types\n    const testSeries = await prisma.webSeries.create({\n      data: {\n        title: 'Test Series',\n        genre: 'Drama',\n        releaseYear: 2023,\n        isActive: true\n      }\n    });\n\n    // Verify field types\n    const fieldTypes = {\n      id: typeof testSeries.id,\n      title: typeof testSeries.title,\n      genre: typeof testSeries.genre,\n      releaseYear: typeof testSeries.releaseYear,\n      isActive: typeof testSeries.isActive\n    };\n\n    res.json({\n      status: 'OK',\n      message: 'Field types validated successfully',\n      fieldTypes,\n      testRecord: testSeries\n    });\n\n    // Clean up test record\n    await prisma.webSeries.delete({\n      where: { id: testSeries.id }\n    });\n\n  } catch (error) {\n    res.status(500).json({\n      status: 'ERROR',\n      message: 'Field validation test failed',\n      error: error.message\n    });\n  }\n});\n\n// Set the port from environment variable or default to 3000\nconst port = process.env.PORT || 3000;\n\n// Start the server\napp.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n});\n\n// Graceful shutdown\nprocess.on('SIGINT', async () => {\n  await prisma.$disconnect();\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', async () => {\n  await prisma.$disconnect();\n  process.exit(0);\n});\n\n// Export app and prisma instances\nmodule.exports = { app, prisma };",
      "schema.prisma": "datasource db {\n  url      = env(\"DATABASE_URL\")\n  provider = \"mysql\"\n}\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\nmodel WebSeries {\n  id          Int     @id @default(autoincrement())\n  title       String\n  genre       String?\n  releaseYear Int?\n  isActive    Boolean @default(true)\n\n  @@map(\"web_series\")\n}"
    }
  },
  {
    "id": 14,
    "title": "Prisma CRUD [MEDIUM]",
    "code": "const { prisma } = require('./db/config');\n\n// 1. Create\nconst createShipping = async ({ userId, productId, count, status }) => {\n  return await prisma.shipping.create({\n    data: { userId, productId, count, status },\n  });\n};\n\n// 2. Get all\nconst getAllShippings = async () => {\n  return await prisma.shipping.findMany();\n};\n\n// 3. Get by ID\nconst getShippingById = async (id) => {\n  return await prisma.shipping.findUnique({ where: { id } });\n};\n\n// 4. Update\nconst updateShipping = async (id, updatedData) => {\n  return await prisma.shipping.update({\n    where: { id },\n    data: updatedData,\n  });\n};\n\n// 5. Delete\nconst deleteShipping = async (id) => {\n  return await prisma.shipping.delete({ where: { id } });\n};\n\nmodule.exports = {\n  createShipping,\n  getAllShippings,\n  getShippingById,\n  updateShipping,\n  deleteShipping,\n};"
  },
  {
    "id": 15,
    "title": "Implement a Signup Route with Email Validation [MEDIUM]",
    "code": "const express = require('express');\nconst { PrismaClient } = require('@prisma/client');\nconst dotenv = require('dotenv');\n\n// Load environment variables\ndotenv.config();\n\n// Creating App\nconst app = express();\n\n// Creating Prisma instance\nconst prisma = new PrismaClient();\n\n// Middleware to parse JSON requests\napp.use(express.json());\n\n// Define routes\napp.get('/', (req, res) => {\n    res.status(200).send(\"Hello World!!\");\n});\n\nfunction isValidEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n}\n\napp.post('/signup', async (req, res) => {\n    const { username, email, password } = req.body;\n\n    // Validate presence of fields\n    if (!username || !email || !password) {\n        return res.status(400).json({ error: \"All fields are required\" });\n    }\n\n    // Validate email format\n    if (!isValidEmail(email)) {\n        return res.status(400).json({ error: \"Invalid email format\" });\n    }\n\n    try {\n        // Check if username or email already exists\n        const existingUser = await prisma.user.findFirst({\n            where: {\n                OR: [\n                    { username: username },\n                    { email: email }\n                ]\n            }\n        });\n\n        if (existingUser) {\n            return res.status(400).json({ error: \"Username or email already exists\" });\n        }\n\n        // Create user\n        const newUser = await prisma.user.create({\n            data: {\n                username,\n                email,\n                password  // stored as plain text for learning only\n            }\n        });\n\n        return res.status(201).json({\n            message: \"User created successfully\",\n            user: {\n                username: newUser.username,\n                email: newUser.email\n            }\n        });\n    } catch (error) {\n        console.error(\"Error creating user:\", error);\n        return res.status(500).json({ error: \"Internal server error\" });\n    }\n});\n\n// Set the port from environment variable or default to 3000\nconst port = process.env.PORT || 3000;\n\n// Start the server\napp.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n});\n\n// Export app and prisma instances\nmodule.exports = { app, prisma };"
  },
  {
    "id": 16,
    "title": "Express.js App — File System, Middleware & Database Tests[MEDIUM]",
    "codes": {
      "index.js": "const express = require('express');\nconst fs = require('fs').promises;\nconst { apiKeyMiddleware } = require('./middleware');\nconst { PrismaClient } = require('@prisma/client');\nconst dotenv = require('dotenv');\ndotenv.config();\n\nconst app = express();\nconst prisma = new PrismaClient();\n\napp.use(express.json());\n\n// POST /write → Append message to file.txt\napp.post('/write', async (req, res) => {\n    const { message } = req.body;\n\n    if (!message) {\n        return res.status(400).json({ error: \"Message field is required\" });\n    }\n\n    try {\n        await fs.appendFile('file.txt', message + '\\n');\n        return res.status(200).json({ status: \"Message written successfully\" });\n    } catch (error) {\n        return res.status(500).json({ error: \"Failed to write to file\" });\n    }\n});\n\n// GET /data → Protected route with middleware\napp.get('/data', apiKeyMiddleware, (req, res) => {\n    return res.status(200).json({ message: \"Protected data accessed\" });\n});\n\n// POST /create → Create a new user with validation\napp.post('/create', async (req, res) => {\n    const { name, email } = req.body;\n\n    if (!name || !email || !email.includes('@') || !email.endsWith('.com')) {\n        return res.status(400).json({ error: 'Invalid name or email' });\n    }\n\n    try {\n        const user = await prisma.user.create({\n            data: { name, email },\n        });\n\n        return res.status(201).json(user);\n    } catch (error) {\n        return res.status(400).json({ error: 'User creation failed (maybe duplicate email)' });\n    }\n});\n\n// GET /users → Fetch all users or specific user by ID\napp.get('/users', async (req, res) => {\n    const userId = req.query.id;\n\n    try {\n        if (userId) {\n            const user = await prisma.user.findUnique({\n                where: { id: parseInt(userId) }\n            });\n\n            if (!user) {\n                return res.status(404).json({ error: \"User not found\" });\n            }\n\n            return res.json(user);\n        } else {\n            const users = await prisma.user.findMany();\n            return res.json(users);\n        }\n    } catch (error) {\n        return res.status(500).json({ error: \"Error fetching users\" });\n    }\n});\n\n// Start server\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n});\n\nmodule.exports = { app, prisma };",
      "middleware.js": "function apiKeyMiddleware(req, res, next) {\n\n    const clientKey = req.headers['apiauthkey'];\n    const serverKey = process.env.API_AUTH_KEY;\n\n    if (!clientKey || clientKey !== serverKey) {\n        return res.status(401).json({ error: \"apiauthkey is missing or invalid\" });\n    }\n\n    next();\n\n};\n\nmodule.exports = { apiKeyMiddleware };"
    }
  },
  {
    "id": 17,
    "title": "Library Management API [HARD]",
    "codes": {
      "src/index.js": "const express = require('express');\nconst dotenv = require('dotenv');\ndotenv.config();\nconst app = express();\nconst path = require(\"path\")\nconst fs = require('fs/promises'); // Use fs/promises for async file operations\nconst { verifyPerson } = require('../middleware/verifyPerson'); // Import middleware\n\napp.use(express.json());\n\nconst libraryRoutes = require('../controller/libraryManagement');\napp.use('/', libraryRoutes);\n\n// Path to the issued.txt file inside the src directory\nconst filePath = path.join(__dirname, 'issued.txt')\n\nconst port = process.env.PORT || 3000;\n\n// ==========================================================\n// EASY SECTION — /health Route\n// ==========================================================\n\napp.get('/health', (req, res) => {\n    res.status(200).json({ \n        \"message\": \"Library health is OK\" \n    });\n});\n\n// ==========================================================\n// MEDIUM SECTION 1 — Middleware + File Handling\n// ==========================================================\n\n// POST /issuebooks route with verifyPerson middleware\napp.post('/issuebooks', verifyPerson, async (req, res) => {\n    try {\n        const logEntry = \"Admin issued a book\\n\";\n        \n        // Append the log entry to issued.txt. \n        // If the file doesn't exist, it will be created.\n        await fs.appendFile(filePath, logEntry, 'utf8');\n\n        return res.status(200).json({\n            \"message\": \"Book issued successfully\"\n        });\n    } catch (error) {\n        console.error(\"File write failed:\", error);\n        // Respond with 500 status on failure\n        return res.status(500).json({\n            \"error\": \"Failed to issue book\"\n        });\n    }\n});\n\n\n// Start the server\napp.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n});\n\n// Export app and prisma instances\nmodule.exports = { app};",
      "middleware/verifyPerson.js": "const verifyPerson = (req, res, next) => {\n    // Check if the role query parameter is 'admin'\n    if (req.query.role === 'admin') {\n        // If 'admin', proceed to the next middleware or route handler\n        next();\n    } else {\n        // If not 'admin', return 403 Forbidden\n        return res.status(403).json({ \n            error: \"You are not allowed to enter\" \n        });\n    }\n};\n\nmodule.exports = {\n    verifyPerson\n};",
      "services/libraryService.js": "const { prisma } = require('../db/config');\n\nasync function createBook(data) {\n    try {\n        const book = await prisma.book.create({\n            data: data,\n        });\n        return book;\n    } catch (error) {\n        // Catch specific Prisma errors (e.g., P2002 unique constraint, P2000 invalid data type)\n        // Re-throw a generic error that the controller can use for a 500/error response.\n        console.error(\"Prisma createBook error:\", error.message);\n        throw new Error(\"Failed to create book in DB due to invalid data.\");\n    }\n}\n\nasync function getAllBooks() {\n    try {\n        const books = await prisma.book.findMany();\n        return books;\n    } catch (error) {\n        console.error(\"Prisma getAllBooks error:\", error.message);\n        throw new Error(\"Failed to fetch books from DB\");\n    }\n}\n\nasync function updateBook(id, data) {\n    try {\n        // Ensure ID conversion is inside the try block for robust error handling\n        const updatedBook = await prisma.book.update({\n            where: { id: parseInt(id) },\n            data: data,\n        });\n        return updatedBook;\n    } catch (error) {\n        // P2025 error for record not found. P2000 for invalid data.\n        console.error(\"Prisma updateBook error:\", error.message);\n        throw new Error(\"Failed to update book in DB\");\n    }\n}\n\nasync function deleteBook(id) {\n    try {\n        const deletedBook = await prisma.book.delete({\n            where: { id: parseInt(id) },\n        });\n        return deletedBook;\n    } catch (error) {\n        // P2025 error for record not found.\n        console.error(\"Prisma deleteBook error:\", error.message);\n        throw new Error(\"Failed to delete book from DB\");\n    }\n}\n\nmodule.exports = {\n    createBook,\n    getAllBooks,\n    updateBook,\n    deleteBook\n};",
      "controller/libraryManagement.js": "const express = require(\"express\")\nconst router = express.Router()\nconst { createBook, getAllBooks, updateBook, deleteBook } = require(\"../services/libraryService\")\n\nconst GENERIC_ERROR_RESPONSE = { \"error\": \"Invalid data or operation failed\" };\n\n// POST /books - Create a book\nrouter.post('/books', async (req, res) => {\n    try {\n        const bookData = req.body;\n        \n        // Input validation: A book must have a title.\n        if (!bookData || !bookData.title || typeof bookData.title !== 'string') {\n            // Test Case 19: If input is invalid, return 500 and the specified error message, \n            // as some test runners may expect 500 for all 'operation failed' errors.\n            return res.status(500).json(GENERIC_ERROR_RESPONSE);\n        }\n        \n        const book = await createBook(bookData);\n        return res.status(201).json({ success: true, book: book });\n    } catch (error) {\n        // Catch service/DB errors and consistently return 500 with the required body.\n        console.error(\"Error in POST /books route:\", error.message);\n        return res.status(500).json(GENERIC_ERROR_RESPONSE);\n    }\n})\n\n// GET /books - Get all books\nrouter.get('/books', async (req, res) => {\n    try {\n        const books = await getAllBooks();\n        return res.status(200).json({ success: true, books: books });\n    } catch (error) {\n        console.error(\"Error in GET /books route:\", error.message);\n        return res.status(500).json(GENERIC_ERROR_RESPONSE);\n    }\n})\n\n// PUT /books/:id - Update a book\nrouter.put('/books/:id', async (req, res) => {\n    try {\n        const { id } = req.params;\n        const updateData = req.body;\n\n        const updated = await updateBook(id, updateData);\n        return res.status(200).json({ success: true, updated: updated });\n    } catch (error) {\n        // Catches update failures (e.g., ID not found, invalid data)\n        console.error(\"Error in PUT /books/:id route:\", error.message);\n        return res.status(500).json(GENERIC_ERROR_RESPONSE);\n    }\n})\n\n// DELETE /books/:id - Delete a book\nrouter.delete('/books/:id', async (req, res) => {\n    try {\n        const { id } = req.params;\n        await deleteBook(id);\n        return res.status(200).json({ success: true, message: \"Book deleted\" });\n    } catch (error) {\n        // Catches deletion failures (e.g., ID not found)\n        console.error(\"Error in DELETE /books/:id route:\", error.message);\n        return res.status(500).json(GENERIC_ERROR_RESPONSE);\n    }\n})\n\nmodule.exports = router"
    }
  },
  {
    "id": 18,
    "title": "Prisma Multi-Field Sorting [MEDIUM]",
    "code": "const { prisma } = require(\"../db/config\");\n\nasync function findUsersSortedByAgeAndName() {\n  // Fetch all users sorted by age asc, then by name (case-insensitive) asc\n  // Prisma doesn't support case-insensitive sorting directly, so we do a workaround using raw SQL\n  const users = await prisma.$queryRaw`\n    SELECT id, name, age\n    FROM User\n    ORDER BY age ASC, LOWER(name) ASC\n  `;\n\n  return users;\n}\n\nmodule.exports = { findUsersSortedByAgeAndName };"
  },
  {
    "id": 19,
    "title": "CRUD API for Product Management using Express, Prisma, and MySQL [EASY]",
    "codes": {
      "index.js": "const express = require('express');\nconst productRoutes = require('./routes/productRoutes');\nconst apiAuthMiddleware = require('./middleware/authMiddleware');\n\nconst app = express();\napp.use(express.json());\n\n// Apply auth middleware to all product routes\napp.use('/api/products', apiAuthMiddleware, productRoutes);\n\n// Handle undefined routes\napp.use((req, res) => {\n  res.status(404).json({ error: 'Route not found' });\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n\nmodule.exports = app;",
      "middleware/authMiddleware.js": "const { VALID_API_KEY } = require('./authkey');\n\nconst apiAuthMiddleware = (req, res, next) => {\n  const key = req.headers['apiauthkey'];\n\n  if (!key) {\n    return res.status(401).json({ message: 'Access denied, apiauthkey is missing' });\n  }\n\n  if (key !== VALID_API_KEY) {\n    return res.status(401).json({ message: 'Failed to authenticate apiauthkey' });\n  }\n\n  next();\n};\n\nmodule.exports = apiAuthMiddleware;",
      "middleware/authKey.js": "// Static valid API key\nmodule.exports = {\n  VALID_API_KEY: \"8a60348b-d4a4-564a-9b45-aab518adb7f4\"\n};",
      "routes/productRoutes.js": "const express = require('express');\nconst { PrismaClient } = require('@prisma/client');\n\nconst prisma = new PrismaClient();\nconst router = express.Router();\n\n// Create Product\nrouter.post('/create', async (req, res) => {\n  const { name, stock, price } = req.body;\n\n  if (!name || stock == null || price == null) {\n    return res.status(400).json({ error: 'All fields required' });\n  }\n\n  try {\n    const product = await prisma.product.create({\n      data: { name, stock, price },\n    });\n    res.status(201).json(product);\n  } catch {\n    res.status(500).json({ error: 'Failed to create product' });\n  }\n});\n\n// Get All Products\nrouter.get('/get', async (req, res) => {\n  try {\n    const products = await prisma.product.findMany();\n    res.status(200).json(products);\n  } catch {\n    res.status(500).json({ error: 'Failed to fetch products' });\n  }\n});\n\n// Get Product by ID\nrouter.get('/getById/:id', async (req, res) => {\n  try {\n    const product = await prisma.product.findUnique({\n      where: { id: parseInt(req.params.id) },\n    });\n\n    if (!product) return res.status(404).json({ error: 'Product not found' });\n\n    res.status(200).json(product);\n  } catch {\n    res.status(500).json({ error: 'Failed to retrieve product' });\n  }\n});\n\n// Full Update Product\nrouter.put('/put/:id', async (req, res) => {\n  const { name, stock, price } = req.body;\n\n  if (!name || stock == null || price == null) {\n    return res.status(400).json({ error: 'All fields required' });\n  }\n\n  try {\n    const updated = await prisma.product.update({\n      where: { id: parseInt(req.params.id) },\n      data: { name, stock, price },\n    });\n\n    res.status(200).json(updated);\n  } catch {\n    res.status(404).json({ error: 'Product not found' });\n  }\n});\n\n// Partial Update Product\nrouter.patch('/patch/:id', async (req, res) => {\n  const { name, stock, price } = req.body;\n\n  try {\n    const updated = await prisma.product.update({\n      where: { id: parseInt(req.params.id) },\n      data: { name, stock, price },\n    });\n\n    res.status(200).json(updated);\n  } catch {\n    res.status(404).json({ error: 'Product not found' });\n  }\n});\n\n// Delete Product\nrouter.delete('/delete/:id', async (req, res) => {\n  try {\n    await prisma.product.delete({\n      where: { id: parseInt(req.params.id) },\n    });\n\n    res.status(200).json({ message: 'Product is deleted' });\n  } catch {\n    res.status(404).json({ error: 'Product not found' });\n  }\n});\n\nmodule.exports = router;",
      "schema.prisma": "generator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"mysql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel Product {\n  id     Int     @id @default(autoincrement())\n  name   String\n  stock  Int\n  price  Float\n}"
    }
  },
  {
    "id": 20,
    "title": "CRUD API for Cart Management Using Express, Prisma and MySQL [EASY]",
    "codes": {
      "index.js": "const express = require('express');\nrequire('dotenv').config();\nconst apiAuthMiddleware = require('./middleware/authMiddleware');\nconst cartRoutes = require('./routes/cartRoutes');\n\nconst app = express();\napp.use(express.json());\n\n// Apply API auth middleware globally\napp.use('/api/cart', apiAuthMiddleware, cartRoutes);\n\n// Catch undefined routes\napp.use((req, res) => {\n  res.status(404).json({ error: 'Route not found' });\n});\n\n// Start the server\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n\nmodule.exports = app;",
      "middleware/authMiddleware.js": "require('dotenv').config();\n\nconst apiAuthMiddleware = (req, res, next) => {\n  const apiKey = req.headers['apiauthkey'];\n\n  if (!apiKey) {\n    return res.status(403).json({ error: 'apiauthkey is missing or invalid' });\n  }\n\n  if (apiKey !== process.env.API_AUTH_KEY) {\n    return res.status(403).json({ error: 'Failed to authenticate apiauthkey' });\n  }\n\n  next();\n};\n\nmodule.exports = apiAuthMiddleware;",
      "routes/cartRoutes.js": "const express = require('express');\nconst { PrismaClient } = require('@prisma/client');\n\nconst prisma = new PrismaClient();\nconst router = express.Router();\n\n// Create cart entry\nrouter.post('/addProduct', async (req, res) => {\n  const { userId, productId, count } = req.body;\n\n  if (!userId || !productId || !count) {\n    return res.status(404).json({ error: 'All fields required' });\n  }\n\n  try {\n    const newCart = await prisma.cart.create({\n      data: { userId, productId, count },\n    });\n\n    res.status(201).json(newCart);\n  } catch (error) {\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// Get cart by ID\nrouter.get('/getById/:id', async (req, res) => {\n  const { id } = req.params;\n\n  try {\n    const cart = await prisma.cart.findUnique({\n      where: { cartId: parseInt(id) },\n    });\n\n    if (!cart) {\n      return res.status(404).json({ error: 'Cart not found' });\n    }\n\n    res.status(200).json(cart);\n  } catch {\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// Patch cart\nrouter.patch('/patch/:id', async (req, res) => {\n  const { id } = req.params;\n  const { count } = req.body;\n\n  try {\n    const updatedCart = await prisma.cart.update({\n      where: { cartId: parseInt(id) },\n      data: { count },\n    });\n\n    res.status(200).json(updatedCart);\n  } catch {\n    res.status(404).json({ error: 'Cart not found' });\n  }\n});\n\n// Delete cart\nrouter.delete('/removeProduct/:id', async (req, res) => {\n  const { id } = req.params;\n\n  try {\n    await prisma.cart.delete({\n      where: { cartId: parseInt(id) },\n    });\n\n    res.status(200).json({ message: 'Cart deleted successfully' });\n  } catch {\n    res.status(404).json({ error: 'Cart not found' });\n  }\n});\n\nmodule.exports = router;",
      "schema.prisma": "generator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"mysql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel Cart {\n  cartId     Int @id @default(autoincrement())\n  userId     Int\n  productId  Int\n  count      Int\n}"
    }
  },
  {
    "id": 11,
    "title": "Delete Product [MEDIUM]",
    "code": "const express = require(\"express\");\nconst EventEmitter = require(\"events\");\n\nconst { pool } = require(\"../db/config.js\");\nconst { createProducts, createCart } = require(\"./migration\");\n\nrequire(\"dotenv\").config();\nconst serverStatus = new EventEmitter();\nconst port = process.env.PORT;\nconst app = express();\napp.use(express.json());\n\napp.post(\"/products\", async (req, res) => {\n  const { name, quantity, price } = req.body;\n  if (!name || !quantity || !price) {\n    return res.status(400).json({ error: \"invalid input\" });\n  }\n  try {\n    const [result] = await pool.query(\n      \"INSERT INTO products (name, quantity, price) VALUES (?, ?, ?)\",\n      [name, quantity, price]\n    );\n    return res.status(201).json({ id: result.insertId, name, quantity, price });\n  } catch (err) {\n    if (err.code === \"ER_DUP_ENTRY\") {\n      return res.status(400).json({ error: \"Product name must be unique\" });\n    }\n    console.error(err);\n    return res.status(500).json({ error: \"Failed to create product\" });\n  }\n});\n\n// Delete product by ID\napp.delete(\"/products/:id\", async (req, res) => {\n  const productId = req.params.id;\n\n  if (isNaN(productId)) {\n    return res.status(400).json({ error: \"Product ID must be a valid number\" });\n  }\n\n  try {\n    const [products] = await pool.query(\n      \"SELECT id FROM products WHERE id = ?\",\n      [productId]\n    );\n\n    if (products.length === 0) {\n      return res.status(404).json({ error: \"Product not found\" });\n    }\n\n    const connection = await pool.getConnection();\n    await connection.beginTransaction();\n\n    try {\n      await connection.query(\n        \"DELETE FROM cart WHERE product_id = ?\",\n        [productId]\n      );\n\n      const [result] = await connection.query(\n        \"DELETE FROM products WHERE id = ?\",\n        [productId]\n      );\n\n      await connection.commit();\n      connection.release();\n\n      return res.status(204).send();\n\n    } catch (transactionError) {\n      await connection.rollback();\n      connection.release();\n      throw transactionError;\n    }\n\n  } catch (err) {\n    console.error(\"Error deleting product:\", err);\n    return res.status(500).json({ error: \"Failed to delete product\" });\n  }\n});\n\npool\n  .getConnection()\n  .then(() => {\n    console.log(\"db connected\");\n  })\n  .then(createProducts)\n  .then(() => {\n    console.log(\"products table created\");\n  })\n  .then(createCart)\n  .then(() => {\n    console.log(\"cart table created\");\n  })\n  .then(() => {\n    app.listen(port, () => {\n      console.log(`Server running at http://localhost:${port}`);\n      serverStatus.emit(\"accepting api calls\");\n    });\n  }).catch((err) => console.log(err));\n\nmodule.exports = { app, serverStatus };"
  },
  {
    "id": 12,
    "title": "Prisma User Model for WebSeries [MEDIUM]",
    "codes": {
      "index.js": "const express = require('express');\nconst dotenv = require('dotenv');\nconst { PrismaClient } = require('@prisma/client');\n\n// Load environment variables\ndotenv.config();\n\n// Creating Prisma instance\nconst prisma = new PrismaClient({\n  log: ['query', 'info', 'warn', 'error'],\n});\n\n// Creating App\nconst app = express();\n\n// Middleware to parse JSON requests\napp.use(express.json());\n\n// Define routes\napp.get('/', (req, res) => {\n    res.status(200).send(\"Hello World!!\");\n});\n\n// Example route to demonstrate Prisma usage\napp.post('/users', async (req, res) => {\n  try {\n    const { name, email, password, role, preferences } = req.body;\n    \n    const user = await prisma.user.create({\n      data: {\n        name,\n        email,\n        password,\n        role: role || \"guest\",\n        preferences\n      }\n    });\n    \n    res.status(201).json(user);\n  } catch (error) {\n    console.error('Error creating user:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\napp.get('/users', async (req, res) => {\n  try {\n    const users = await prisma.user.findMany();\n    res.json(users);\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// Set the port from environment variable or default to 3000\nconst port = process.env.PORT || 3000;\n\n// Start the server\napp.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n});\n\n// Graceful shutdown\nprocess.on('SIGINT', async () => {\n  await prisma.$disconnect();\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', async () => {\n  await prisma.$disconnect();\n  process.exit(0);\n});\n\n// Export app and prisma instances\nmodule.exports = { app, prisma };",
      "schema.prisma": "datasource db {\n  url      = env(\"DATABASE_URL\")\n  provider = \"mysql\"\n}\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\nmodel User {\n  id          Int      @id @default(autoincrement())\n  name        String\n  email       String   @unique\n  password    String\n  role        String   @default(\"guest\")\n  preferences Json?\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n\n  @@map(\"users\")\n}"
    }
  },
  {
    "id": 13,
    "title": "Build a WebSeries Table Using Prisma [MEDIUM]",
    "codes": {
      "index.js": "const express = require('express');\nconst { PrismaClient } = require('@prisma/client');\nconst dotenv = require('dotenv');\n\n// Load environment variables\ndotenv.config();\n\n// Creating App\nconst app = express();\n\n// Creating Prisma instance\nconst prisma = new PrismaClient({\n  log: ['query', 'info', 'warn', 'error'],\n});\n\n// Middleware to parse JSON requests\napp.use(express.json());\n\n// Define routes\napp.get('/', (req, res) => {\n    res.status(200).send(\"Hello World!!\");\n});\n\n// WebSeries routes\napp.post('/web-series', async (req, res) => {\n  try {\n    const { title, genre, releaseYear, isActive } = req.body;\n    \n    if (!title) {\n      return res.status(400).json({ error: 'Title is required' });\n    }\n\n    const webSeries = await prisma.webSeries.create({\n      data: {\n        title,\n        genre,\n        releaseYear,\n        isActive: isActive !== undefined ? isActive : true\n      }\n    });\n    \n    res.status(201).json(webSeries);\n  } catch (error) {\n    console.error('Error creating web series:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\napp.get('/web-series', async (req, res) => {\n  try {\n    const webSeries = await prisma.webSeries.findMany({\n      orderBy: {\n        id: 'asc'\n      }\n    });\n    res.json(webSeries);\n  } catch (error) {\n    console.error('Error fetching web series:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\napp.get('/web-series/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const webSeries = await prisma.webSeries.findUnique({\n      where: { id: parseInt(id) }\n    });\n\n    if (!webSeries) {\n      return res.status(404).json({ error: 'Web series not found' });\n    }\n\n    res.json(webSeries);\n  } catch (error) {\n    console.error('Error fetching web series:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\napp.put('/web-series/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { title, genre, releaseYear, isActive } = req.body;\n\n    const webSeries = await prisma.webSeries.update({\n      where: { id: parseInt(id) },\n      data: {\n        title,\n        genre,\n        releaseYear,\n        isActive\n      }\n    });\n\n    res.json(webSeries);\n  } catch (error) {\n    if (error.code === 'P2025') {\n      return res.status(404).json({ error: 'Web series not found' });\n    }\n    console.error('Error updating web series:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\napp.delete('/web-series/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    await prisma.webSeries.delete({\n      where: { id: parseInt(id) }\n    });\n\n    res.status(204).send();\n  } catch (error) {\n    if (error.code === 'P2025') {\n      return res.status(404).json({ error: 'Web series not found' });\n    }\n    console.error('Error deleting web series:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// Test endpoint for Prisma client\napp.get('/test/prisma', async (req, res) => {\n  try {\n    // Test Prisma connection\n    await prisma.$queryRaw`SELECT 1`;\n    \n    // Test WebSeries table access\n    const count = await prisma.webSeries.count();\n    \n    res.json({\n      status: 'OK',\n      message: 'Prisma client is working correctly',\n      tableAccess: 'WebSeries table is accessible',\n      totalRecords: count\n    });\n  } catch (error) {\n    res.status(500).json({\n      status: 'ERROR',\n      message: 'Prisma client test failed',\n      error: error.message\n    });\n  }\n});\n\n// Test endpoint for field validation\napp.get('/test/fields', async (req, res) => {\n  try {\n    // Create a test record to validate field types\n    const testSeries = await prisma.webSeries.create({\n      data: {\n        title: 'Test Series',\n        genre: 'Drama',\n        releaseYear: 2023,\n        isActive: true\n      }\n    });\n\n    // Verify field types\n    const fieldTypes = {\n      id: typeof testSeries.id,\n      title: typeof testSeries.title,\n      genre: typeof testSeries.genre,\n      releaseYear: typeof testSeries.releaseYear,\n      isActive: typeof testSeries.isActive\n    };\n\n    res.json({\n      status: 'OK',\n      message: 'Field types validated successfully',\n      fieldTypes,\n      testRecord: testSeries\n    });\n\n    // Clean up test record\n    await prisma.webSeries.delete({\n      where: { id: testSeries.id }\n    });\n\n  } catch (error) {\n    res.status(500).json({\n      status: 'ERROR',\n      message: 'Field validation test failed',\n      error: error.message\n    });\n  }\n});\n\n// Set the port from environment variable or default to 3000\nconst port = process.env.PORT || 3000;\n\n// Start the server\napp.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n});\n\n// Graceful shutdown\nprocess.on('SIGINT', async () => {\n  await prisma.$disconnect();\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', async () => {\n  await prisma.$disconnect();\n  process.exit(0);\n});\n\n// Export app and prisma instances\nmodule.exports = { app, prisma };",
      "schema.prisma": "datasource db {\n  url      = env(\"DATABASE_URL\")\n  provider = \"mysql\"\n}\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\nmodel WebSeries {\n  id          Int     @id @default(autoincrement())\n  title       String\n  genre       String?\n  releaseYear Int?\n  isActive    Boolean @default(true)\n\n  @@map(\"web_series\")\n}"
    }
  },
  {
    "id": 14,
    "title": "Prisma CRUD [MEDIUM]",
    "code": "const { prisma } = require('./db/config');\n\n// 1. Create\nconst createShipping = async ({ userId, productId, count, status }) => {\n  return await prisma.shipping.create({\n    data: { userId, productId, count, status },\n  });\n};\n\n// 2. Get all\nconst getAllShippings = async () => {\n  return await prisma.shipping.findMany();\n};\n\n// 3. Get by ID\nconst getShippingById = async (id) => {\n  return await prisma.shipping.findUnique({ where: { id } });\n};\n\n// 4. Update\nconst updateShipping = async (id, updatedData) => {\n  return await prisma.shipping.update({\n    where: { id },\n    data: updatedData,\n  });\n};\n\n// 5. Delete\nconst deleteShipping = async (id) => {\n  return await prisma.shipping.delete({ where: { id } });\n};\n\nmodule.exports = {\n  createShipping,\n  getAllShippings,\n  getShippingById,\n  updateShipping,\n  deleteShipping,\n};"
  },
  {
    "id": 15,
    "title": "Implement a Signup Route with Email Validation [MEDIUM]",
    "code": "const express = require('express');\nconst { PrismaClient } = require('@prisma/client');\nconst dotenv = require('dotenv');\n\n// Load environment variables\ndotenv.config();\n\n// Creating App\nconst app = express();\n\n// Creating Prisma instance\nconst prisma = new PrismaClient();\n\n// Middleware to parse JSON requests\napp.use(express.json());\n\n// Define routes\napp.get('/', (req, res) => {\n    res.status(200).send(\"Hello World!!\");\n});\n\nfunction isValidEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n}\n\napp.post('/signup', async (req, res) => {\n    const { username, email, password } = req.body;\n\n    // Validate presence of fields\n    if (!username || !email || !password) {\n        return res.status(400).json({ error: \"All fields are required\" });\n    }\n\n    // Validate email format\n    if (!isValidEmail(email)) {\n        return res.status(400).json({ error: \"Invalid email format\" });\n    }\n\n    try {\n        // Check if username or email already exists\n        const existingUser = await prisma.user.findFirst({\n            where: {\n                OR: [\n                    { username: username },\n                    { email: email }\n                ]\n            }\n        });\n\n        if (existingUser) {\n            return res.status(400).json({ error: \"Username or email already exists\" });\n        }\n\n        // Create user\n        const newUser = await prisma.user.create({\n            data: {\n                username,\n                email,\n                password  // stored as plain text for learning only\n            }\n        });\n\n        return res.status(201).json({\n            message: \"User created successfully\",\n            user: {\n                username: newUser.username,\n                email: newUser.email\n            }\n        });\n    } catch (error) {\n        console.error(\"Error creating user:\", error);\n        return res.status(500).json({ error: \"Internal server error\" });\n    }\n});\n\n// Set the port from environment variable or default to 3000\nconst port = process.env.PORT || 3000;\n\n// Start the server\napp.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n});\n\n// Export app and prisma instances\nmodule.exports = { app, prisma };"
  },
  {
    "id": 16,
    "title": "Express.js App — File System, Middleware & Database Tests[MEDIUM]",
    "codes": {
      "index.js": "const express = require('express');\nconst fs = require('fs').promises;\nconst { apiKeyMiddleware } = require('./middleware');\nconst { PrismaClient } = require('@prisma/client');\nconst dotenv = require('dotenv');\ndotenv.config();\n\nconst app = express();\nconst prisma = new PrismaClient();\n\napp.use(express.json());\n\n// POST /write → Append message to file.txt\napp.post('/write', async (req, res) => {\n    const { message } = req.body;\n\n    if (!message) {\n        return res.status(400).json({ error: \"Message field is required\" });\n    }\n\n    try {\n        await fs.appendFile('file.txt', message + '\\n');\n        return res.status(200).json({ status: \"Message written successfully\" });\n    } catch (error) {\n        return res.status(500).json({ error: \"Failed to write to file\" });\n    }\n});\n\n// GET /data → Protected route with middleware\napp.get('/data', apiKeyMiddleware, (req, res) => {\n    return res.status(200).json({ message: \"Protected data accessed\" });\n});\n\n// POST /create → Create a new user with validation\napp.post('/create', async (req, res) => {\n    const { name, email } = req.body;\n\n    if (!name || !email || !email.includes('@') || !email.endsWith('.com')) {\n        return res.status(400).json({ error: 'Invalid name or email' });\n    }\n\n    try {\n        const user = await prisma.user.create({\n            data: { name, email },\n        });\n\n        return res.status(201).json(user);\n    } catch (error) {\n        return res.status(400).json({ error: 'User creation failed (maybe duplicate email)' });\n    }\n});\n\n// GET /users → Fetch all users or specific user by ID\napp.get('/users', async (req, res) => {\n    const userId = req.query.id;\n\n    try {\n        if (userId) {\n            const user = await prisma.user.findUnique({\n                where: { id: parseInt(userId) }\n            });\n\n            if (!user) {\n                return res.status(404).json({ error: \"User not found\" });\n            }\n\n            return res.json(user);\n        } else {\n            const users = await prisma.user.findMany();\n            return res.json(users);\n        }\n    } catch (error) {\n        return res.status(500).json({ error: \"Error fetching users\" });\n    }\n});\n\n// Start server\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n});\n\nmodule.exports = { app, prisma };",
      "middleware.js": "function apiKeyMiddleware(req, res, next) {\n\n    const clientKey = req.headers['apiauthkey'];\n    const serverKey = process.env.API_AUTH_KEY;\n\n    if (!clientKey || clientKey !== serverKey) {\n        return res.status(401).json({ error: \"apiauthkey is missing or invalid\" });\n    }\n\n    next();\n\n};\n\nmodule.exports = { apiKeyMiddleware };"
    }
  },
  {
    "id": 17,
    "title": "Library Management API [HARD]",
    "codes": {
      "src/index.js": "const express = require('express');\nconst dotenv = require('dotenv');\ndotenv.config();\nconst app = express();\nconst path = require(\"path\")\nconst fs = require('fs/promises'); // Use fs/promises for async file operations\nconst { verifyPerson } = require('../middleware/verifyPerson'); // Import middleware\n\napp.use(express.json());\n\nconst libraryRoutes = require('../controller/libraryManagement');\napp.use('/', libraryRoutes);\n\n// Path to the issued.txt file inside the src directory\nconst filePath = path.join(__dirname, 'issued.txt')\n\nconst port = process.env.PORT || 3000;\n\n// ==========================================================\n// EASY SECTION — /health Route\n// ==========================================================\n\napp.get('/health', (req, res) => {\n    res.status(200).json({ \n        \"message\": \"Library health is OK\" \n    });\n});\n\n// ==========================================================\n// MEDIUM SECTION 1 — Middleware + File Handling\n// ==========================================================\n\n// POST /issuebooks route with verifyPerson middleware\napp.post('/issuebooks', verifyPerson, async (req, res) => {\n    try {\n        const logEntry = \"Admin issued a book\\n\";\n        \n        // Append the log entry to issued.txt. \n        // If the file doesn't exist, it will be created.\n        await fs.appendFile(filePath, logEntry, 'utf8');\n\n        return res.status(200).json({\n            \"message\": \"Book issued successfully\"\n        });\n    } catch (error) {\n        console.error(\"File write failed:\", error);\n        // Respond with 500 status on failure\n        return res.status(500).json({\n            \"error\": \"Failed to issue book\"\n        });\n    }\n});\n\n\n// Start the server\napp.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n});\n\n// Export app and prisma instances\nmodule.exports = { app};",
      "middleware/verifyPerson.js": "const verifyPerson = (req, res, next) => {\n    // Check if the role query parameter is 'admin'\n    if (req.query.role === 'admin') {\n        // If 'admin', proceed to the next middleware or route handler\n        next();\n    } else {\n        // If not 'admin', return 403 Forbidden\n        return res.status(403).json({ \n            error: \"You are not allowed to enter\" \n        });\n    }\n};\n\nmodule.exports = {\n    verifyPerson\n};",
      "services/libraryService.js": "const { prisma } = require('../db/config');\n\nasync function createBook(data) {\n    try {\n        const book = await prisma.book.create({\n            data: data,\n        });\n        return book;\n    } catch (error) {\n        // Catch specific Prisma errors (e.g., P2002 unique constraint, P2000 invalid data type)\n        // Re-throw a generic error that the controller can use for a 500/error response.\n        console.error(\"Prisma createBook error:\", error.message);\n        throw new Error(\"Failed to create book in DB due to invalid data.\");\n    }\n}\n\nasync function getAllBooks() {\n    try {\n        const books = await prisma.book.findMany();\n        return books;\n    } catch (error) {\n        console.error(\"Prisma getAllBooks error:\", error.message);\n        throw new Error(\"Failed to fetch books from DB\");\n    }\n}\n\nasync function updateBook(id, data) {\n    try {\n        // Ensure ID conversion is inside the try block for robust error handling\n        const updatedBook = await prisma.book.update({\n            where: { id: parseInt(id) },\n            data: data,\n        });\n        return updatedBook;\n    } catch (error) {\n        // P2025 error for record not found. P2000 for invalid data.\n        console.error(\"Prisma updateBook error:\", error.message);\n        throw new Error(\"Failed to update book in DB\");\n    }\n}\n\nasync function deleteBook(id) {\n    try {\n        const deletedBook = await prisma.book.delete({\n            where: { id: parseInt(id) },\n        });\n        return deletedBook;\n    } catch (error) {\n        // P2025 error for record not found.\n        console.error(\"Prisma deleteBook error:\", error.message);\n        throw new Error(\"Failed to delete book from DB\");\n    }\n}\n\nmodule.exports = {\n    createBook,\n    getAllBooks,\n    updateBook,\n    deleteBook\n};",
      "controller/libraryManagement.js": "const express = require(\"express\")\nconst router = express.Router()\nconst { createBook, getAllBooks, updateBook, deleteBook } = require(\"../services/libraryService\")\n\nconst GENERIC_ERROR_RESPONSE = { \"error\": \"Invalid data or operation failed\" };\n\n// POST /books - Create a book\nrouter.post('/books', async (req, res) => {\n    try {\n        const bookData = req.body;\n        \n        // Input validation: A book must have a title.\n        if (!bookData || !bookData.title || typeof bookData.title !== 'string') {\n            // Test Case 19: If input is invalid, return 500 and the specified error message, \n            // as some test runners may expect 500 for all 'operation failed' errors.\n            return res.status(500).json(GENERIC_ERROR_RESPONSE);\n        }\n        \n        const book = await createBook(bookData);\n        return res.status(201).json({ success: true, book: book });\n    } catch (error) {\n        // Catch service/DB errors and consistently return 500 with the required body.\n        console.error(\"Error in POST /books route:\", error.message);\n        return res.status(500).json(GENERIC_ERROR_RESPONSE);\n    }\n})\n\n// GET /books - Get all books\nrouter.get('/books', async (req, res) => {\n    try {\n        const books = await getAllBooks();\n        return res.status(200).json({ success: true, books: books });\n    } catch (error) {\n        console.error(\"Error in GET /books route:\", error.message);\n        return res.status(500).json(GENERIC_ERROR_RESPONSE);\n    }\n})\n\n// PUT /books/:id - Update a book\nrouter.put('/books/:id', async (req, res) => {\n    try {\n        const { id } = req.params;\n        const updateData = req.body;\n\n        const updated = await updateBook(id, updateData);\n        return res.status(200).json({ success: true, updated: updated });\n    } catch (error) {\n        // Catches update failures (e.g., ID not found, invalid data)\n        console.error(\"Error in PUT /books/:id route:\", error.message);\n        return res.status(500).json(GENERIC_ERROR_RESPONSE);\n    }\n})\n\n// DELETE /books/:id - Delete a book\nrouter.delete('/books/:id', async (req, res) => {\n    try {\n        const { id } = req.params;\n        await deleteBook(id);\n        return res.status(200).json({ success: true, message: \"Book deleted\" });\n    } catch (error) {\n        // Catches deletion failures (e.g., ID not found)\n        console.error(\"Error in DELETE /books/:id route:\", error.message);\n        return res.status(500).json(GENERIC_ERROR_RESPONSE);\n    }\n})\n\nmodule.exports = router"
    }
  },
  {
    "id": 18,
    "title": "Prisma Multi-Field Sorting [MEDIUM]",
    "code": "const { prisma } = require(\"../db/config\");\n\nasync function findUsersSortedByAgeAndName() {\n  // Fetch all users sorted by age asc, then by name (case-insensitive) asc\n  // Prisma doesn't support case-insensitive sorting directly, so we do a workaround using raw SQL\n  const users = await prisma.$queryRaw`\n    SELECT id, name, age\n    FROM User\n    ORDER BY age ASC, LOWER(name) ASC\n  `;\n\n  return users;\n}\n\nmodule.exports = { findUsersSortedByAgeAndName };"
  },
  {
    "id": 19,
    "title": "CRUD API for Product Management using Express, Prisma, and MySQL [EASY]",
    "codes": {
      "index.js": "const express = require('express');\nconst productRoutes = require('./routes/productRoutes');\nconst apiAuthMiddleware = require('./middleware/authMiddleware');\n\nconst app = express();\napp.use(express.json());\n\n// Apply auth middleware to all product routes\napp.use('/api/products', apiAuthMiddleware, productRoutes);\n\n// Handle undefined routes\napp.use((req, res) => {\n  res.status(404).json({ error: 'Route not found' });\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n\nmodule.exports = app;",
      "middleware/authMiddleware.js": "const { VALID_API_KEY } = require('./authkey');\n\nconst apiAuthMiddleware = (req, res, next) => {\n  const key = req.headers['apiauthkey'];\n\n  if (!key) {\n    return res.status(401).json({ message: 'Access denied, apiauthkey is missing' });\n  }\n\n  if (key !== VALID_API_KEY) {\n    return res.status(401).json({ message: 'Failed to authenticate apiauthkey' });\n  }\n\n  next();\n};\n\nmodule.exports = apiAuthMiddleware;",
      "middleware/authKey.js": "// Static valid API key\nmodule.exports = {\n  VALID_API_KEY: \"8a60348b-d4a4-564a-9b45-aab518adb7f4\"\n};",
      "routes/productRoutes.js": "const express = require('express');\nconst { PrismaClient } = require('@prisma/client');\n\nconst prisma = new PrismaClient();\nconst router = express.Router();\n\n// Create Product\nrouter.post('/create', async (req, res) => {\n  const { name, stock, price } = req.body;\n\n  if (!name || stock == null || price == null) {\n    return res.status(400).json({ error: 'All fields required' });\n  }\n\n  try {\n    const product = await prisma.product.create({\n      data: { name, stock, price },\n    });\n    res.status(201).json(product);\n  } catch {\n    res.status(500).json({ error: 'Failed to create product' });\n  }\n});\n\n// Get All Products\nrouter.get('/get', async (req, res) => {\n  try {\n    const products = await prisma.product.findMany();\n    res.status(200).json(products);\n  } catch {\n    res.status(500).json({ error: 'Failed to fetch products' });\n  }\n});\n\n// Get Product by ID\nrouter.get('/getById/:id', async (req, res) => {\n  try {\n    const product = await prisma.product.findUnique({\n      where: { id: parseInt(req.params.id) },\n    });\n\n    if (!product) return res.status(404).json({ error: 'Product not found' });\n\n    res.status(200).json(product);\n  } catch {\n    res.status(500).json({ error: 'Failed to retrieve product' });\n  }\n});\n\n// Full Update Product\nrouter.put('/put/:id', async (req, res) => {\n  const { name, stock, price } = req.body;\n\n  if (!name || stock == null || price == null) {\n    return res.status(400).json({ error: 'All fields required' });\n  }\n\n  try {\n    const updated = await prisma.product.update({\n      where: { id: parseInt(req.params.id) },\n      data: { name, stock, price },\n    });\n\n    res.status(200).json(updated);\n  } catch {\n    res.status(404).json({ error: 'Product not found' });\n  }\n});\n\n// Partial Update Product\nrouter.patch('/patch/:id', async (req, res) => {\n  const { name, stock, price } = req.body;\n\n  try {\n    const updated = await prisma.product.update({\n      where: { id: parseInt(req.params.id) },\n      data: { name, stock, price },\n    });\n\n    res.status(200).json(updated);\n  } catch {\n    res.status(404).json({ error: 'Product not found' });\n  }\n});\n\n// Delete Product\nrouter.delete('/delete/:id', async (req, res) => {\n  try {\n    await prisma.product.delete({\n      where: { id: parseInt(req.params.id) },\n    });\n\n    res.status(200).json({ message: 'Product is deleted' });\n  } catch {\n    res.status(404).json({ error: 'Product not found' });\n  }\n});\n\nmodule.exports = router;",
      "schema.prisma": "generator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"mysql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel Product {\n  id     Int     @id @default(autoincrement())\n  name   String\n  stock  Int\n  price  Float\n}"
    }
  },
  {
    "id": 20,
    "title": "CRUD API for Cart Management Using Express, Prisma and MySQL [EASY]",
    "codes": {
      "index.js": "const express = require('express');\nrequire('dotenv').config();\nconst apiAuthMiddleware = require('./middleware/authMiddleware');\nconst cartRoutes = require('./routes/cartRoutes');\n\nconst app = express();\napp.use(express.json());\n\n// Apply API auth middleware globally\napp.use('/api/cart', apiAuthMiddleware, cartRoutes);\n\n// Catch undefined routes\napp.use((req, res) => {\n  res.status(404).json({ error: 'Route not found' });\n});\n\n// Start the server\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n\nmodule.exports = app;",
      "middleware/authMiddleware.js": "require('dotenv').config();\n\nconst apiAuthMiddleware = (req, res, next) => {\n  const apiKey = req.headers['apiauthkey'];\n\n  if (!apiKey) {\n    return res.status(403).json({ error: 'apiauthkey is missing or invalid' });\n  }\n\n  if (apiKey !== process.env.API_AUTH_KEY) {\n    return res.status(403).json({ error: 'Failed to authenticate apiauthkey' });\n  }\n\n  next();\n};\n\nmodule.exports = apiAuthMiddleware;",
      "routes/cartRoutes.js": "const express = require('express');\nconst { PrismaClient } = require('@prisma/client');\n\nconst prisma = new PrismaClient();\nconst router = express.Router();\n\n// Create cart entry\nrouter.post('/addProduct', async (req, res) => {\n  const { userId, productId, count } = req.body;\n\n  if (!userId || !productId || !count) {\n    return res.status(404).json({ error: 'All fields required' });\n  }\n\n  try {\n    const newCart = await prisma.cart.create({\n      data: { userId, productId, count },\n    });\n\n    res.status(201).json(newCart);\n  } catch (error) {\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// Get cart by ID\nrouter.get('/getById/:id', async (req, res) => {\n  const { id } = req.params;\n\n  try {\n    const cart = await prisma.cart.findUnique({\n      where: { cartId: parseInt(id) },\n    });\n\n    if (!cart) {\n      return res.status(404).json({ error: 'Cart not found' });\n    }\n\n    res.status(200).json(cart);\n  } catch {\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// Patch cart\nrouter.patch('/patch/:id', async (req, res) => {\n  const { id } = req.params;\n  const { count } = req.body;\n\n  try {\n    const updatedCart = await prisma.cart.update({\n      where: { cartId: parseInt(id) },\n      data: { count },\n    });\n\n    res.status(200).json(updatedCart);\n  } catch {\n    res.status(404).json({ error: 'Cart not found' });\n  }\n});\n\n// Delete cart\nrouter.delete('/removeProduct/:id', async (req, res) => {\n  const { id } = req.params;\n\n  try {\n    await prisma.cart.delete({\n      where: { cartId: parseInt(id) },\n    });\n\n    res.status(200).json({ message: 'Cart deleted successfully' });\n  } catch {\n    res.status(404).json({ error: 'Cart not found' });\n  }\n});\n\nmodule.exports = router;",
      "schema.prisma": "generator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"mysql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel Cart {\n  cartId     Int @id @default(autoincrement())\n  userId     Int\n  productId  Int\n  count      Int\n}"
    }
  },
  {
    "id": 21,
    "title": "Node.js CLI Calculator [EASY]",
    "code": "const args = process.argv.slice(2);\n\nconst operation = args[0]\n\nconst num1 = Number(args[1])\nconst num2 = Number(args[2])\n\nlet result;\n\nswitch (operation) {\n    case 'add':\n    result = num1 + num2;\n    break;\n\n    case 'subtract':\n    result = num1 - num2;\n    break;\n\n    case 'multiply':\n    result = num1 * num2;\n    break;\n\n    case 'divide':\n    result = num1 / num2;\n    break;\n\n    default:\n    console.log('Invalid operation')\n}\n\nconsole.log(result)"
  },
  {
    "id": 22,
    "title": "Fetching item with id [EASY]",
    "code": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // Handle GET / request\n  if (req.method === 'GET' && req.url === '/') {\n    res.writeHead(200, { 'Content-Type': 'text/plain' });\n    res.end('Home page');\n    return;\n  }\n\n  // Handle GET /item/:id request\n  if (req.method === 'GET' && req.url.startsWith('/item/')) {\n    // Extract the id manually from the URL\n    const parts = req.url.split('/');\n    if (parts.length === 3 && parts[2] !== '') {\n      const id = parts[2];\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end(`Fetching item with id ${id}`);\n      return;\n    }\n  }\n\n  // Handle all other routes - 404 Not Found\n  res.writeHead(404, { 'Content-Type': 'text/plain' });\n  res.end('404 Not Found');\n});\n\nserver.listen(3000, () => {\n  console.log('Server listening on port 3000');\n});\n\nmodule.exports = { server };"
  },
  {
    "id": 23,
    "title": "Create a Calculator with Http [MEDIUM]",
    "code": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst INPUT_FILE = path.join(__dirname, \"../inputs.txt\");\nconst OUTPUT_FILE = path.join(__dirname, \"../result.txt\");\nconsole.log(INPUT_FILE, OUTPUT_FILE);\n\nconst server = http.createServer((req, res) => {\n  const url = req.url;\n  const method = req.method;\n  if (method === \"GET\" && url === \"/calculate\") {\n      fs.readFile(INPUT_FILE, \"utf-8\", (err, data) => {\n        if (err) {\n          res.writeHead(500, { \"Content-type\": \"text/plain\" })\n          res.end(\"Unable to write result\");        \n        } else {\n          const [a, b, operation] = data.split(\"\\n\");\n          if (!isNaN(a) && !isNaN(b)) {\n            const numA = parseInt(a);\n            const numB = parseInt(b);\n            switch (operation) {\n              case \"add\":\n                fs.writeFileSync(OUTPUT_FILE, String(numA + numB))\n                res.writeHead(200, { \"Content-type\": \"text/plain\" })\n                res.end(String(numA + numB));\n                break;\n              case \"subtract\":\n                fs.writeFileSync(OUTPUT_FILE, String(numA - numB))\n                res.writeHead(200, { \"Content-type\": \"text/plain\" })\n                res.end(String(numA - numB));\n                break;\n              case \"multiply\":\n                fs.writeFileSync(OUTPUT_FILE, String(numA * numB))\n                res.writeHead(200, { \"Content-type\": \"text/plain\" })\n                res.end(String(numA * numB));\n                break;\n              case \"divide\":\n                if (numB === 0) {\n                  fs.writeFileSync(OUTPUT_FILE, \"Division by zero\")\n                  res.writeHead(400, { \"Content-type\": \"text/plain\" })\n                  res.end(\"Division by zero\");\n                  break;\n                }\n                fs.writeFileSync(OUTPUT_FILE, String(numA / numB))\n                res.writeHead(200, { \"Content-type\": \"text/plain\" })\n                res.end(String(numA / numB));\n                break;\n              \n              default:\n                res.writeHead(400, { \"Content-type\": \"text/plain\" })\n                res.end(\"Invalid Operator\");        \n                break;\n            }\n          } else {\n            fs.writeFileSync(OUTPUT_FILE, \"Invalid Number\")\n            res.writeHead(400, { \"Content-type\": \"text/plain\" })\n            res.end(\"Invalid Number\");\n          }\n        }\n      });\n  } else {\n    res.writeHead(404, { \"Content-type\": \"text/plain\" })\n    res.end(\"Not Found\");\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server is listening on port 3000');\n});\n\nmodule.exports = server;"
  },    
  {
    "id": 24,
    "title": "Delete todo asynchronously and return Promise [MEDIUM]",
    "code": "const fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst DB_FILE_PATH = path.join(__dirname, \"db.txt\");\n/**\n * Converts a string from db.txt format into an array of todo objects.\n *\n * @param {string} text - A raw string representing todos, each serialized as JSON and separated by newlines.\n * @returns {Object[]} An array of todo objects parsed from the input text.\n *\n * @example\n * const text = '{\"id\":1,\"task\":\"Do laundry\"}\\n{\"id\":2,\"task\":\"Buy milk\"}';\n * const todos = dbTextToJson(text);\n */\nconst dbTextToJson = (text) => {\n  const formattedString = `[${text.trim().split(\"\\n}\\n{\").join(\"},{\")}]`;\n  const jsonArray = JSON.parse(formattedString);\n  return jsonArray;\n};\n\n/**\n * Converts an array of todo objects into a string suitable for saving in db.txt.\n *\n * @param {Object[]} Json - An array of todo objects.\n * @returns {string} A string where each object is serialized as pretty-printed JSON and separated by newlines.\n *\n * @example\n * const todos = [{ id: 1, task: \"Do laundry\" }, { id: 2, task: \"Buy milk\" }];\n * const text = JsonToDbText(todos);\n */\nconst JsonToDbText = (Json) => {\n  let text = \"\";\n  Json.forEach((todo) => {\n    text += JSON.stringify(todo, null, 2) + \"\\n\";\n  });\n  return text;\n};\n\nconst deleteTodo = (id) => {\n  return new Promise((resolve, reject) => {\n    fs.promises.readFile(DB_FILE_PATH, 'utf8')\n      .then(data => {\n        let todos = dbTextToJson(data);\n        const initialLength = todos.length;\n        todos = todos.filter(todo => todo.id !== id);\n        if (todos.length === initialLength) {\n          resolve();\n        } else {\n          const updatedText = JsonToDbText(todos);\n          return fs.promises.writeFile(DB_FILE_PATH, updatedText);\n        }\n      })\n      .then(() => {\n        resolve();\n      })\n      .catch(error => {\n        reject(error);\n      });\n  });\n};\nreturn deleteTodo;"
  },
  {
    "id": 25,
    "title": "Asynchronous File Concatenator",
    "code": "const fs = require('fs').promises;\nconst path = require('path');\n\nasync function cat(filePaths, outputFilePath) {\n  const outputLines = [];\n  \n  for (const filePath of filePaths) {\n    try {\n      // Check if the path exists and get its stats\n      const stats = await fs.stat(filePath);\n      \n      if (stats.isFile()) {\n        // Read file content if it's a file\n        const content = await fs.readFile(filePath, 'utf8');\n        outputLines.push(content);\n      } else if (stats.isDirectory()) {\n        // Append directory message\n        outputLines.push('Is a directory');\n      } else {\n        // Handle other types (shouldn't normally happen)\n        outputLines.push('File not found');\n      }\n    } catch (error) {\n      // Handle any errors (file not found, permission issues, etc.)\n      outputLines.push('File not found');\n    }\n  }\n  \n  // Join all lines with newline character and write to output file\n  const outputContent = outputLines.join('\\n');\n  await fs.writeFile(outputFilePath, outputContent, 'utf8');\n}\n\nmodule.exports = { cat };\n\n// Other Method -->\n\n/*\nconst fs = require('fs').promises;\n\nasync function cat(filePaths, outputFilePath) {\n  const results = [];\n  \n  for (const filePath of filePaths) {\n    try {\n      // Try to read the file first (will fail if it's a directory or doesn't exist)\n      const content = await fs.readFile(filePath, 'utf8');\n      results.push(content);\n    } catch (error) {\n      if (error.code === 'EISDIR') {\n        // It's a directory\n        results.push('Is a directory');\n      } else {\n        // File not found or other error\n        results.push('File not found');\n      }\n    }\n  }\n  \n  await fs.writeFile(outputFilePath, results.join('\\n'), 'utf8');\n}\n\nmodule.exports = { cat };\n*/"
  },
  {
    "id": 26,
    "title": "API Endpoint Implementation: Product Search and Filtering [MEDIUM]",
    "code": "const express = require('express');\nconst app = express();\nconst port = 3000;\nconst path = require('path');\nconst fs = require('fs');\n\napp.get('/products', (req, res) => {\n    const dbPath = path.join(__dirname, 'db.json');\n    let allProducts = JSON.parse(fs.readFileSync(dbPath, 'utf8'));\n \n    // Write your code here\n    const { name, minPrice, maxPrice } = req.query;\n    \n    // Validate minPrice if provided\n    if (minPrice !== undefined) {\n        const minPriceNum = parseFloat(minPrice);\n        if (isNaN(minPriceNum)) {\n            return res.status(400).json({ \"error\": \"Invalid minPrice\" });\n        }\n    }\n    \n    // Validate maxPrice if provided\n    if (maxPrice !== undefined) {\n        const maxPriceNum = parseFloat(maxPrice);\n        if (isNaN(maxPriceNum)) {\n            return res.status(400).json({ \"error\": \"Invalid maxPrice\" });\n        }\n    }\n    \n    // Validate minPrice and maxPrice relationship\n    if (minPrice !== undefined && maxPrice !== undefined) {\n        const minPriceNum = parseFloat(minPrice);\n        const maxPriceNum = parseFloat(maxPrice);\n        if (minPriceNum > maxPriceNum) {\n            return res.status(400).json({ \"error\": \"minPrice cannot be greater than maxPrice\" });\n        }\n    }\n    \n    // Apply filters\n    let filteredProducts = [...allProducts];\n    \n    // Filter by name (case-insensitive)\n    if (name) {\n        const searchTerm = name.toLowerCase();\n        filteredProducts = filteredProducts.filter(product => \n            product.name.toLowerCase().includes(searchTerm)\n        );\n    }\n    \n    // Filter by minPrice\n    if (minPrice !== undefined) {\n        const minPriceNum = parseFloat(minPrice);\n        filteredProducts = filteredProducts.filter(product => \n            product.price >= minPriceNum\n        );\n    }\n    \n    // Filter by maxPrice\n    if (maxPrice !== undefined) {\n        const maxPriceNum = parseFloat(maxPrice);\n        filteredProducts = filteredProducts.filter(product => \n            product.price <= maxPriceNum\n        );\n    }\n    \n    res.json(filteredProducts);\n});\n\napp.listen(port, () => {\n    console.log(`Product API listening at http://localhost:${port}`);\n});\n\nmodule.exports = { app };"
  },
  {
    "id": 27,
    "title": "Validation Middleware — Medium Level [MEDIUM]",
    "codes": {
      "index.js": "const express = require(\"express\");\nconst dotenv = require(\"dotenv\");\n\nconst app = express();\ndotenv.config();\n\nconst { validateUser } = require(\"./validateMiddleware\");\n\napp.get(\"/user\", validateUser, (req, res) => {\n  res.status(200).json({\n    message: `Welcome, ${req.query.name} from ${req.query.city}! your age is ${req.query.age}`\n  });\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server running on http://localhost:${PORT}`);\n});",
      
      "validateMiddleware.js": "function validateUser(req, res, next) {\n    const { name, age, city } = req.query;\n    \n    // Validate name -->\n    if (!name || typeof name !== 'string' || name.trim() === '') {\n        return res.status(400).json({ error: \"Invalid input\" });\n    }\n    \n    // Validate age -->\n    if (!age) {\n        return res.status(400).json({ error: \"Invalid input\" });\n    }\n    \n    const ageNum = parseInt(age, 10);\n    if (isNaN(ageNum) || ageNum < 18) {\n        return res.status(400).json({ error: \"Invalid input\" });\n    }\n    \n    // Validate city -->\n    if (!city || typeof city !== 'string' || city.trim() === '') {\n        return res.status(400).json({ error: \"Invalid input\" });\n    }\n    \n    // All validations passed, call next() -->\n    next();\n}\n\nmodule.exports = { validateUser };"
    }
  },
  {
    "id": 28,
    "title": "Pagination Endpoint in Express [MEDIUM]",
    "code": "const express = require(\"express\");\nconst app = express();\n\n// Sample in-memory data (IDs 1–30)\nconst products = Array.from({ length: 30 }, (_, i) => ({\n  id: i + 1,\n  name: `Product ${i + 1}`\n}));\n\n// Pagination endpoint\napp.get(\"/products\", (req, res) => {\n  // Parse query parameters with defaults\n  let page = parseInt(req.query.page);\n  let limit = parseInt(req.query.limit);\n  \n  // Validate and set defaults for invalid values\n  if (isNaN(page) || page < 1) page = 1;\n  if (isNaN(limit) || limit < 1) limit = 10;\n  \n  // Calculate start and end indices\n  const startIndex = (page - 1) * limit;\n  const endIndex = startIndex + limit;\n  \n  // Get the paginated slice of products\n  const paginatedProducts = products.slice(startIndex, endIndex);\n  \n  res.status(200).json(paginatedProducts);\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server running on http://localhost:${PORT}`);\n});"
  },
  {
    "id": 29,
    "title": "Get Product by ID Mysql2 [MEDIUM]",
    "codes": {
      "index.js": "const express = require(\"express\");\nconst EventEmitter = require(\"events\");\n\nconst { pool } = require(\"../db/config.js\");\nconst { createProducts, createCart } = require(\"./migration\");\n\nrequire(\"dotenv\").config();\nconst serverStatus = new EventEmitter();\nconst port = process.env.PORT;\nconst app = express();\napp.use(express.json());\n\napp.post(\"/products\", async (req, res) => {\n  const { name, quantity, price } = req.body;\n  if (!name || !quantity || !price) {\n    return res.status(400).json({ error: \"invalid input\" });\n  }\n  try {\n    const [result] = await pool.query(\n      \"INSERT INTO products (name, quantity, price) VALUES (?, ?, ?)\",\n      [name, quantity, price]\n    );\n    return res.status(201).json({ id: result.insertId, name, quantity, price });\n  } catch (err) {\n    if (err.code === \"ER_DUP_ENTRY\") {\n      // Handle duplicate entry error\n      return res.status(400).json({ error: \"Product name must be unique\" });\n    }\n    console.error(err);\n    return res.status(500).json({ error: \"Failed to create product\" });\n  }\n});\n\n// Read single product by ID\napp.get(\"/products/:id\", async (req, res) => {\n  const productId = req.params.id;\n  \n  // Validate that ID is a number\n  if (isNaN(productId)) {\n    return res.status(400).json({ error: \"Invalid product ID\" });\n  }\n  \n  try {\n    const [rows] = await pool.query(\n      \"SELECT * FROM products WHERE id = ?\",\n      [productId]\n    );\n    \n    if (rows.length === 0) {\n      return res.status(404).json({ error: \"Product not found\" });\n    }\n    \n    return res.status(200).json(rows[0]);\n  } catch (err) {\n    console.error(\"Error fetching product:\", err);\n    return res.status(500).json({ error: \"Failed to fetch product\" });\n  }\n});\n\npool\n  .getConnection()\n  .then(() => {\n    console.log(\"db connected\");\n  })\n  .then(createProducts)\n  .then(() => {\n    console.log(\"products table created\");\n  })\n  .then(createCart)\n  .then(() => {\n    console.log(\"cart table created\");\n  })\n  .then(() => {\n    app.listen(port, () => {\n      console.log(`Server running at http://localhost:${port}`);\n      serverStatus.emit(\"accepting api calls\");\n    });\n  }).catch((err) => console.log(err));\n\nmodule.exports = { app, serverStatus };",
      "migration.js": "const { pool } = require(\"../db/config\");\n\nconst createProducts = () =>\n  pool.query(`CREATE TABLE IF NOT EXISTS products (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(100) UNIQUE NOT NULL,\n    quantity INT NOT NULL,\n    price INT NOT NULL\n);\n`);\n\nconst createCart = () =>\n  pool.query(`CREATE TABLE IF NOT EXISTS cart (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    product_id INT NOT NULL,\n    quantity INT NOT NULL,\n    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE\n);\n`);\n\nmodule.exports = { createProducts, createCart };"
    }
  },
  {
    "id": 30,
    "title": "Update a product [HARD]",
    "codes": {
      "index.js": "const express = require(\"express\");\nconst EventEmitter = require(\"events\");\n\nconst { pool } = require(\"../db/config.js\");\nconst { createProducts, createCart } = require(\"./migration\");\n\nrequire(\"dotenv\").config();\nconst serverStatus = new EventEmitter();\nconst port = process.env.PORT;\nconst app = express();\napp.use(express.json());\n\napp.post(\"/product\", async (req, res) => {\n  const { name, quantity, price } = req.body;\n  if (!name || !quantity || !price) {\n    return res.status(400).json({ error: \"invalid input\" });\n  }\n  try {\n    const [result] = await pool.query(\n      \"INSERT INTO products (name, quantity, price) VALUES (?, ?, ?)\",\n      [name, quantity, price]\n    );\n    return res.status(201).json({ id: result.insertId, name, quantity, price });\n  } catch (err) {\n    if (err.code === \"ER_DUP_ENTRY\") {\n      // Handle duplicate entry error\n      return res.status(400).json({ error: \"Product name must be unique\" });\n    }\n    console.error(err);\n    return res.status(500).json({ error: \"Failed to create product\" });\n  }\n});\n\n// Update product by ID\napp.put(\"/product/:id\", async (req, res) => {\n  const productId = req.params.id;\n  const { name, quantity, price } = req.body;\n\n  // a. Invalid ID Parameter\n  if (isNaN(productId)) {\n    return res.status(400).json({ error: \"Product ID must be a valid number.\" });\n  }\n\n  try {\n    // Check if product exists first\n    const [existingProducts] = await pool.query(\n      \"SELECT * FROM products WHERE id = ?\",\n      [productId]\n    );\n\n    // b. Product Not Found\n    if (existingProducts.length === 0) {\n      return res.status(404).json({ error: \"Product not found.\" });\n    }\n\n    const currentProduct = existingProducts[0];\n\n    // c. Quantity Validation - Check cart quantity\n    if (quantity !== undefined) {\n      const [cartItems] = await pool.query(\n        \"SELECT SUM(quantity) as totalCartQuantity FROM cart WHERE product_id = ?\",\n        [productId]\n      );\n      \n      const totalCartQuantity = cartItems[0].totalCartQuantity || 0;\n      \n      if (quantity < totalCartQuantity) {\n        return res.status(400).json({ \n          error: `Updated quantity (${quantity}) is less than the quantity in the cart (${totalCartQuantity}).` \n        });\n      }\n    }\n\n    // d. Duplicate Name Error - Check if name already exists for another product\n    if (name && name !== currentProduct.name) {\n      const [existingNames] = await pool.query(\n        \"SELECT id FROM products WHERE name = ? AND id != ?\",\n        [name, productId]\n      );\n      \n      if (existingNames.length > 0) {\n        return res.status(400).json({ error: \"Product name must be unique.\" });\n      }\n    }\n\n    // Build the update query dynamically based on provided fields\n    const updateFields = [];\n    const updateValues = [];\n    \n    if (name !== undefined) {\n      updateFields.push(\"name = ?\");\n      updateValues.push(name);\n    }\n    \n    if (quantity !== undefined) {\n      updateFields.push(\"quantity = ?\");\n      updateValues.push(quantity);\n    }\n    \n    if (price !== undefined) {\n      updateFields.push(\"price = ?\");\n      updateValues.push(price);\n    }\n    \n    // If no fields to update\n    if (updateFields.length === 0) {\n      return res.status(400).json({ error: \"No fields to update.\" });\n    }\n    \n    updateValues.push(productId);\n    \n    const updateQuery = `UPDATE products SET ${updateFields.join(\", \")} WHERE id = ?`;\n    \n    // Execute the update\n    await pool.query(updateQuery, updateValues);\n    \n    // Get the updated product\n    const [updatedProducts] = await pool.query(\n      \"SELECT * FROM products WHERE id = ?\",\n      [productId]\n    );\n    \n    const updatedProduct = updatedProducts[0];\n    \n    return res.status(200).json({\n      message: \"Product updated successfully.\",\n      updatedData: {\n        id: updatedProduct.id,\n        name: updatedProduct.name,\n        quantity: updatedProduct.quantity,\n        price: updatedProduct.price\n      }\n    });\n\n  } catch (err) {\n    console.error(\"Error updating product:\", err);\n    \n    // Handle duplicate entry error specifically\n    if (err.code === \"ER_DUP_ENTRY\") {\n      return res.status(400).json({ error: \"Product name must be unique.\" });\n    }\n    \n    // e. General Server Error\n    return res.status(500).json({ error: \"Failed to update product.\" });\n  }\n});\n\npool\n  .getConnection()\n  .then(() => {\n    console.log(\"db connected\");\n  })\n  .then(createProducts)\n  .then(() => {\n    console.log(\"products table created\");\n  })\n  .then(createCart)\n  .then(() => {\n    console.log(\"cart table created\");\n  })\n  .then(() => {\n    app.listen(port, () => {\n      console.log(`Server running at http://localhost:${port}`);\n      serverStatus.emit(\"accepting api calls\");\n    });\n  }).catch((err) => console.log(err));\n\nmodule.exports = { app, serverStatus };",
      "migration.js": "const { pool } = require(\"../db/config\");\n\nconst createProducts = () =>\n  pool.query(`CREATE TABLE IF NOT EXISTS products (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(100) UNIQUE NOT NULL,\n    quantity INT NOT NULL,\n    price INT NOT NULL\n);\n`);\n\nconst createCart = () =>\n  pool.query(`CREATE TABLE IF NOT EXISTS cart (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    product_id INT NOT NULL,\n    quantity INT NOT NULL,\n    FOREIGN KEY (product_id) REFERENCES products(id)\n);\n`);\n\nmodule.exports = { createProducts, createCart };"
    }
  },
  {
    "id": 31,
    "title": "Prisma Seeding [EASY]",
    "codes": {
      "seed.js": "const { PrismaClient } = require('@prisma/client');\nconst prisma = new PrismaClient();\n\nasync function main() {\n    console.log('Starting seed process...');\n\n    // Define the users data\n    const usersData = [\n        {\n            name: 'Alice Johnson',\n            email: 'alice@example.com',\n            age: 30\n        },\n        {\n            name: 'Bob Smith',\n            email: 'bob@example.com',\n            age: 25\n        },\n        {\n            name: 'Charlie Brown',\n            email: 'charlie@example.com',\n            age: 35\n        }\n    ];\n\n    try {\n        // Check if users already exist to avoid duplicate emails\n        const existingUsers = await prisma.user.findMany({\n            where: {\n                email: {\n                    in: usersData.map(user => user.email)\n                }\n            }\n        });\n\n        if (existingUsers.length > 0) {\n            console.log('Some users already exist. Skipping seed...');\n            console.log('Existing users:', existingUsers.map(u => u.email));\n            return;\n        }\n\n        // Use createMany to insert all users at once\n        const result = await prisma.user.createMany({\n            data: usersData,\n            skipDuplicates: true // Skip if any duplicates exist\n        });\n\n        console.log(`✅ Successfully seeded ${result.count} users into the database.`);\n        console.log('Seeded users:');\n        usersData.forEach(user => {\n            console.log(`  - ${user.name} (${user.email}), Age: ${user.age}`);\n        });\n\n    } catch (error) {\n        console.error('❌ Error during seeding:', error.message);\n        \n        // Handle specific error cases for test validation\n        if (error.code === 'P2002') {\n            console.error('Duplicate email found. Emails must be unique.');\n        } else if (error.code === 'P2003') {\n            console.error('Invalid data provided.');\n        } else if (error.code === 'P2012') {\n            console.error('Missing required fields.');\n        }\n        \n        throw error; // Re-throw to ensure test cases can catch it\n    }\n}\n\nmain()\n    .then(async () => {\n        await prisma.$disconnect();\n        console.log('Seed process completed.');\n    })\n    .catch(async (error) => {\n        console.error('Seed process failed:', error);\n        await prisma.$disconnect();\n        process.exit(1);\n    });\n\nmodule.exports = { main };",
      "schema.prisma": "generator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"mysql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id    Int    @id @default(autoincrement())\n  name  String\n  email String @unique\n  age   Int\n\n  @@map(\"users\")\n}"
    }
  },
  {
    "id": 32,
    "title": "Seeding - User with 3 Posts [EASY]",
    "codes": {
      "seed.js": "const { PrismaClient } = require('@prisma/client');\nconst prisma = new PrismaClient();\n\nasync function main() {\n    console.log('🌱 Starting seeding process...');\n\n    try {\n        // Check if user already exists to avoid duplicates\n        const existingUser = await prisma.user.findUnique({\n            where: {\n                email: 'aadarsh@example.com'\n            },\n            include: {\n                posts: true\n            }\n        });\n\n        if (existingUser) {\n            console.log('⚠️ User already exists. Cleaning up existing data...');\n            \n            // Delete existing posts first (due to foreign key constraints)\n            await prisma.post.deleteMany({\n                where: {\n                    authorId: existingUser.id\n                }\n            });\n            \n            // Delete the user\n            await prisma.user.delete({\n                where: {\n                    id: existingUser.id\n                }\n            });\n            \n            console.log('✅ Existing user and posts removed.');\n        }\n\n        // Create user with posts in a transaction to ensure data integrity\n        const result = await prisma.$transaction(async (tx) => {\n            // Create the user\n            const user = await tx.user.create({\n                data: {\n                    name: 'Aadarsh',\n                    email: 'aadarsh@example.com'\n                }\n            });\n\n            console.log('✅ User created:', user);\n\n            // Validate user data\n            if (!user.name || user.name.trim() === '') {\n                throw new Error('User name cannot be null or empty');\n            }\n            if (!user.email || user.email.trim() === '') {\n                throw new Error('User email cannot be null or empty');\n            }\n\n            // Create posts array with validation\n            const postsData = [\n                {\n                    title: 'First Post by Aadarsh',\n                    content: 'This is the content for Aadarsh\\'s first post.',\n                    published: true,\n                    authorId: user.id\n                },\n                {\n                    title: 'Second Post by Aadarsh',\n                    content: 'Content for Aadarsh\\'s second post.',\n                    published: false,\n                    authorId: user.id\n                },\n                {\n                    title: 'Third Post by Aadarsh',\n                    content: 'Content for Aadarsh\\'s third post.',\n                    published: true,\n                    authorId: user.id\n                }\n            ];\n\n            // Validate posts data before insertion\n            postsData.forEach((post, index) => {\n                if (!post.title || post.title.trim() === '') {\n                    throw new Error(`Post ${index + 1} title cannot be null or empty`);\n                }\n                if (!post.content || post.content.trim() === '') {\n                    throw new Error(`Post ${index + 1} content cannot be null or empty`);\n                }\n                if (post.published === null || post.published === undefined) {\n                    throw new Error(`Post ${index + 1} published status cannot be null`);\n                }\n            });\n\n            // Create all posts\n            const posts = await tx.post.createMany({\n                data: postsData\n            });\n\n            console.log(`✅ ${posts.count} posts created successfully`);\n\n            return { user, posts };\n        });\n\n        // Fetch the created data to verify\n        const createdUser = await prisma.user.findUnique({\n            where: {\n                email: 'aadarsh@example.com'\n            },\n            include: {\n                posts: {\n                    orderBy: {\n                        id: 'asc'\n                    }\n                }\n            }\n        });\n\n        // Display results\n        console.log('\\n📊 Seeding Results:');\n        console.log(`✅ Created user: ${createdUser.name} (${createdUser.email})`);\n        console.log(`✅ Created ${createdUser.posts.length} posts:`);\n        \n        createdUser.posts.forEach((post, index) => {\n            console.log(`   ${index + 1}. \"${post.title}\" - Published: ${post.published}`);\n        });\n\n        // Validate the final result\n        await validateSeeding(createdUser);\n\n        console.log('\\n🎉 Seeding completed successfully!');\n\n    } catch (error) {\n        console.error('❌ Seeding failed:', error.message);\n        throw error;\n    }\n}\n\n// Validation function to ensure data meets requirements\nasync function validateSeeding(user) {\n    console.log('\\n🔍 Validating seeded data...');\n\n    // Test Case 1: User validation\n    if (!user.name || user.name.trim() === '') {\n        throw new Error('User name is null or empty');\n    }\n    if (!user.email || user.email.trim() === '') {\n        throw new Error('User email is null or empty');\n    }\n    console.log('✅ User data validation passed');\n\n    // Test Case 2: Count validation\n    if (user.posts.length !== 3) {\n        throw new Error(`Expected 3 posts, but found ${user.posts.length}`);\n    }\n    console.log('✅ User and post count validation passed');\n\n    // Test Case 3: Post linking validation\n    user.posts.forEach((post, index) => {\n        if (post.authorId !== user.id) {\n            throw new Error(`Post ${index + 1} is not correctly linked to the user`);\n        }\n    });\n    console.log('✅ Post linking validation passed');\n\n    // Test Case 4: Post field validation\n    user.posts.forEach((post, index) => {\n        if (!post.title || post.title.trim() === '') {\n            throw new Error(`Post ${index + 1} title is null or empty`);\n        }\n        if (!post.content || post.content.trim() === '') {\n            throw new Error(`Post ${index + 1} content is null or empty`);\n        }\n        if (post.published === null || post.published === undefined) {\n            throw new Error(`Post ${index + 1} published status is null`);\n        }\n    });\n    console.log('✅ Post field validation passed');\n\n    // Test Case 5: Published status validation\n    const expectedPublishedStatus = [true, false, true];\n    user.posts.forEach((post, index) => {\n        if (post.published !== expectedPublishedStatus[index]) {\n            throw new Error(`Post ${index + 1} published status is incorrect. Expected: ${expectedPublishedStatus[index]}, Got: ${post.published}`);\n        }\n    });\n    console.log('✅ Published status validation passed');\n\n    console.log('🎯 All validation tests passed!');\n}\n\nmain()\n    .then(async () => {\n        await prisma.$disconnect();\n    })\n    .catch(async (error) => {\n        console.error('❌ Seeding process failed:', error);\n        await prisma.$disconnect();\n        process.exit(1);\n    });\n\nmodule.exports = { main };",
      "schema.prisma": "datasource db {\n  url      = env(\"DATABASE_URL\")\n  provider = \"mysql\"\n}\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\nmodel User {\n  id        Int      @id @default(autoincrement()) // Auto-increment primary key\n  name      String   // User's name\n  email     String   @unique\n  posts     Post[]   \n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement()) // Auto-increment primary key\n  title     String   // Title of the post\n  content   String   // Content of the post\n  published Boolean  // Whether the post is published or not\n  authorId  Int      // Foreign key referencing the User model\n  author    User     @relation(fields: [authorId], references: [id]) // Relationship to the User model\n}"
    }
  },
  {
    "id": 33,
    "title": "Implement a Signup Route with Email Validation [MEDIUM]",
    "codes": {
      "index.js": "const express = require('express');\nconst { PrismaClient } = require('@prisma/client');\nconst dotenv = require('dotenv');\n\n// Load environment variables\ndotenv.config();\n\n// Creating App\nconst app = express();\n\n// Creating Prisma instance\nconst prisma = new PrismaClient();\n\n// Middleware to parse JSON requests\napp.use(express.json());\n\n// Define routes\napp.get('/', (req, res) => {\n    res.status(200).send(\"Hello World!!\");\n});\n\nfunction isValidEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n}\n\napp.post('/signup', async (req, res) => {\n    const { username, email, password } = req.body;\n\n    // Validate presence of fields\n    if (!username || !email || !password) {\n        return res.status(400).json({ error: \"All fields are required\" });\n    }\n\n    // Validate email format\n    if (!isValidEmail(email)) {\n        return res.status(400).json({ error: \"Invalid email format\" });\n    }\n\n    try {\n        // Check if username or email already exists\n        const existingUser = await prisma.user.findFirst({\n            where: {\n                OR: [\n                    { username: username },\n                    { email: email }\n                ]\n            }\n        });\n\n        if (existingUser) {\n            return res.status(400).json({ error: \"Username or email already exists\" });\n        }\n\n        // Create user\n        const newUser = await prisma.user.create({\n            data: {\n                username,\n                email,\n                password  // stored as plain text for learning only\n            }\n        });\n\n        return res.status(201).json({\n            message: \"User created successfully\",\n            user: {\n                username: newUser.username,\n                email: newUser.email\n            }\n        });\n    } catch (error) {\n        console.error(\"Error creating user:\", error);\n        return res.status(500).json({ error: \"Internal server error\" });\n    }\n});\n\n// Set the port from environment variable or default to 3000\nconst port = process.env.PORT || 3000;\n\n// Start the server\napp.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n});\n\n// Export app and prisma instances\nmodule.exports = { app, prisma };",
      "schema.prisma": "datasource db {\n  url      = env(\"DATABASE_URL\")\n  provider = \"mysql\"\n}\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\nmodel User {\n  id        Int      @id @default(autoincrement())\n  username  String   @unique\n  email     String   @unique\n  password  String\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}"
    }
  },
  {
    "id": 34,
    "title": "Product: Update by ID [MEDIUM]",
    "code": "const express = require(\"express\");\nconst EventEmitter = require(\"events\");\n\nconst { pool } = require(\"../db/config.js\");\nconst { createProducts, createCart } = require(\"./migration\");\n\nrequire(\"dotenv\").config();\nconst serverStatus = new EventEmitter();\nconst port = process.env.PORT;\nconst app = express();\napp.use(express.json());\n\napp.post(\"/products\", async (req, res) => {\n  const { name, quantity, price } = req.body;\n  if (!name || !quantity || !price) {\n    return res.status(400).json({ error: \"invalid input\" });\n  }\n  try {\n    const [result] = await pool.query(\n      \"INSERT INTO products (name, quantity, price) VALUES (?, ?, ?)\",\n      [name, quantity, price]\n    );\n    return res.status(201).json({ id: result.insertId, name, quantity, price });\n  } catch (err) {\n    if (err.code === \"ER_DUP_ENTRY\") {\n      return res.status(400).json({ error: \"Product name must be unique\" });\n    }\n    console.error(err);\n    return res.status(500).json({ error: \"Failed to create product\" });\n  }\n});\n\napp.put(\"/products/:id\", async (req, res) => {\n  const productId = req.params.id;\n  const { name, quantity, price } = req.body;\n\n  if (isNaN(productId)) {\n    return res.status(400).json({ error: \"Product ID must be a numeric value\" });\n  }\n\n  try {\n    const [existingProducts] = await pool.query(\n      \"SELECT * FROM products WHERE id = ?\",\n      [productId]\n    );\n\n    if (existingProducts.length === 0) {\n      return res.status(404).json({ error: \"Product not found\" });\n    }\n\n    const currentProduct = existingProducts[0];\n\n    if (name && name !== currentProduct.name) {\n      const [existingNames] = await pool.query(\n        \"SELECT id FROM products WHERE name = ? AND id != ?\",\n        [name, productId]\n      );\n      if (existingNames.length > 0) {\n        return res.status(400).json({ error: \"Product name must be unique\" });\n      }\n    }\n\n    const updateFields = [];\n    const updateValues = [];\n\n    if (name !== undefined) {\n      updateFields.push(\"name = ?\");\n      updateValues.push(name);\n    }\n\n    if (quantity !== undefined) {\n      updateFields.push(\"quantity = ?\");\n      updateValues.push(quantity);\n    }\n\n    if (price !== undefined) {\n      updateFields.push(\"price = ?\");\n      updateValues.push(price);\n    }\n\n    if (updateFields.length === 0) {\n      return res.status(400).json({ error: \"No fields provided for update\" });\n    }\n\n    updateValues.push(productId);\n\n    const updateQuery = `UPDATE products SET ${updateFields.join(\", \")} WHERE id = ?`;\n\n    await pool.query(updateQuery, updateValues);\n\n    const [updatedProducts] = await pool.query(\n      \"SELECT * FROM products WHERE id = ?\",\n      [productId]\n    );\n\n    const updatedProduct = updatedProducts[0];\n\n    return res.status(200).json({\n      message: \"Product is updated successfully\",\n      updatedData: {\n        id: updatedProduct.id,\n        name: updatedProduct.name,\n        quantity: updatedProduct.quantity,\n        price: updatedProduct.price\n      }\n    });\n\n  } catch (err) {\n    console.error(\"Error updating product:\", err);\n    if (err.code === \"ER_DUP_ENTRY\") {\n      return res.status(400).json({ error: \"Product name must be unique\" });\n    }\n    return res.status(500).json({ error: \"Failed to update product\" });\n  }\n});\n\npool\n  .getConnection()\n  .then(() => {\n    console.log(\"db connected\");\n  })\n  .then(createProducts)\n  .then(() => {\n    console.log(\"products table created\");\n  })\n  .then(createCart)\n  .then(() => {\n    console.log(\"cart table created\");\n  })\n  .then(() => {\n    app.listen(port, () => {\n      console.log(`Server running at http://localhost:${port}`);\n      serverStatus.emit(\"accepting api calls\");\n    });\n  }).catch((err) => console.log(err));\n\nmodule.exports = { app, serverStatus };"
  },
  {
    "id": 35,
    "title": "Promise.allSettled polyfill [HARD]",
    "code": "Promise.myAllSettled = function (promises) {\n    if (!Array.isArray(promises)) {\n        return Promise.reject(new TypeError('Input must be an array'));\n    }\n\n    if (promises.length === 0) {\n        return Promise.resolve([]);\n    }\n\n    const results = new Array(promises.length);\n    let completed = 0;\n\n    return new Promise((resolve) => {\n        promises.forEach((promise, index) => {\n            Promise.resolve(promise)\n                .then(value => {\n                    results[index] = { status: 'fulfilled', value };\n                })\n                .catch(reason => {\n                    results[index] = { status: 'rejected', reason };\n                })\n                .finally(() => {\n                    completed++;\n                    if (completed === promises.length) {\n                        resolve(results);\n                    }\n                });\n        });\n    });\n}"
  }
]
